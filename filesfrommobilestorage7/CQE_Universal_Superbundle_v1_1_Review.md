# CQE Universal Superbundle v1.1 — Structural Review

**Unpacked to:** `/mnt/data/superbundle_v1_1`
**Total files:** 339

## Top-level directories (by file count)
- `packages_all` — 260 files
- `sources` — 63 files
- `checkpoint_v1_0` — 12 files
- `server` — 2 files
- `MANIFEST.json` — 1 files
- `README_SUPERBUNDLE.txt` — 1 files

## Most common file types
- `.py` — 205
- `.md` — 43
- `.docx` — 32
- `.pdf` — 12
- `.png` — 11
- `.txt` — 6
- `.json` — 5
- `<none>` — 5
- `.html` — 4
- `.toml` — 4
- `.css` — 3
- `.js` — 3
- `.sh` — 1
- `.yml` — 1
- `.conf` — 1
- `.zip` — 1
- `.service` — 1
- `.pptx` — 1

## Top Python imports (rough frequency)
- typing: 227
- : 170
- numpy: 155
- json: 116
- cqe: 99
- time: 86
- dataclasses: 76
- math: 72
- pathlib: 55
- os: 53
- hashlib: 52
- sys: 36
- collections: 34
- enum: 34
- random: 34
- matplotlib: 32
- scipy: 30
- itertools: 23
- logging: 19
- argparse: 17
- agents: 14
- cqe_system: 14
- __future__: 13
- pytest: 12
- threading: 10
- subprocess: 10
- datetime: 9
- re: 9
- urllib: 8
- morphonic_cqe_unified: 8
- abc: 8
- embeddings: 8
- pickle: 7
- networkx: 7
- mpl_toolkits: 7
- pandas: 7
- sklearn: 6
- requests: 6
- agrm_profiler_diagnostics: 6
- agrm_runtime_controller: 6
- tsp_node_loader: 6
- agrm_results_export: 6
- agrm_modulation_and_legalgraph: 6
- unittest: 6
- tempfile: 6
- seaborn: 6
- traceback: 5
- psutil: 5
- wsgiref: 4
- cmath: 4

## Notable documents / previews
### packages_all/GeoTokenizer_TieIn_v1/GeoTokenizer_TieIn_v1/README.md
```text

# GeoTokenizer Tie-In v1

A geometry-first token codec + memory manager for the Geometry-Only Transformer v2.

## Capabilities
- Encode/decode lists of points into compact bytes (quantized + varints + zlib).
- Break/extend/combine/refine token sequences.
- Learn "equivalence tokens" from past data and convert new inputs to canonical tokens.
- Merkle-chained ledger of operations (`.geo_tokenizer/ledger.jsonl`).

## CLI
```bash
# encode/decode
python geo_tokenizer_tiein_v1.py encode --in-json pts.json --out shape.geo
python geo_tokenizer_tiein_v1.py decode --in shape.geo --out-json pts_out.json

# learn a prototype and convert later inputs
python geo_tokenizer_tiein_v1.py learn --name HEX --from-json hex6.json
python geo_tokenizer_tiein_v1.py convert --from-json mystery.json

# synthesize/extend/refine/break
python geo_tokenizer_tiein_v1.py synthesize --n 8 --k 3
python geo_tokenizer_tiein_v1.py extend --from-json partial.json --target-n 12
python geo_tokenizer_tiein_v1.py refine --from-json trace.json --iters 3
python geo_tokenizer_tiein_v1.py break --from-json trace.json --idx 10
```

```

### packages_all/MonsterMoonshineDB_v1/MonsterMoonshineDB_v1/README.md
```text

# Monster/Moonshine VOA Embedding DB — Personal HTML Server

Pure-stdlib personal server for CQE-style embeddings with Moonshine/VOA flavor.

## Run
```bash
python server.py  # http://127.0.0.1:8765
```
Use the UI to add items and search. API: `/api/add`, `/api/search`, `/api/get`, `/api/list`, `/api/stats`.

## Extend
- Edit `embedding/voa_moonshine.py` to inject more McKay–Thompson coefficients (CSV import easy to add).
- Replace `embedding/geometry_bridge.py` with your Scene8/WorldForge descriptors if desired.
- Add more charts (e.g., Niemeier theta) by computing features and storing under a new chart name.

```

### packages_all/LatticeBuilder_Validator_v1/LatticeBuilder_Validator_v1/README.md
```text

# Lattice Builder & Validator v1 (pure stdlib)

**What it does**
- Build ADE root-lattice Gram matrices from specs like `E8^3`, `A8 + D16`, `A1^24`.
- Validate integrality, evenness, determinant & unimodularity.
- Enumerate short vectors (Fincke–Pohst style) to detect roots (norm 2) and minimal norms.
- Check 24D even–unimodular candidates and distinguish **Leech** vs. **(rooted) Niemeier** by root presence.

**Why this is sound (mathematically)**
- Root lattices have Gram = Cartan matrix (diag 2, -1 along Dynkin edges). Evenness ⇒ diagonal entries even, and the lattice generated by simple roots has roots precisely at squared-length 2.
- In 24D, **Niemeier’s classification** says there are 23 even unimodular lattices with roots (labeled by their Dynkin diagrams) and exactly **one rootless**: the **Leech lattice**. So: even + unimodular + rank 24 + rootless ⇒ Leech.

**Use**
```bash
# 1) Build a Gram matrix for E8^3 and save as JSON
python lattice_builder_v1.py build "E8^3" --out e8x3_gram.json

# 2) Validate lattice properties
python lattice_builder_v1.py validate --gram-json e8x3_gram.json

# 3) Enumerate short vectors to find roots of norm 2
python lattice_builder_v1.py roots --gram-json e8x3_gram.json --bound 2.0

# 4) Niemeier check (24D)
python lattice_builder_v1.py build "A1^24" --out a1x24.json
python lattice_builder_v1.py validate --gram-json a1x24.json
python lattice_builder_v1.py niemeier --gram-json a1x24.json
```

**Notes**
- Enumeration is exponential; good for confirming root presence (norm 2) and small bounds. Don’t expect full vector listings in 24D.
- This module does *not* construct overlattices via glue codes. It’s a validator for the base root lattices and for the Leech/“rootless” test on 24D even–unimodular candidates.
- You can feed any symmetric positive-definite Gram in JSON to `validate` and `roots`.

**Integrations**
- Sidecar: wrap invocations in your receipts engine; store hashes of the Gram JSON and the property report.
- Geometry stack: export your geometry-native prototypes to ADE specs or to explicit Grams and run this checker as a guardrail.

```

### packages_all/Viewer24_Controller_v2_CA/Viewer24_Controller_v2_CA/README.md
```text

# Viewer24 Controller v2 + Dihedral CA Overlay (pure stdlib)

Dihedrally connected cellular automaton overlay spanning 24 screens (6x4). Global
grid ensures seam continuity; each tile uses a distinct Julia parameter derived
from its Niemeier label, giving unique but edge-aligned dynamics. Colors follow
an approximate electromagnetic spectrum mapping, with angle banding.

Run:
  python viewer_api.py
  # open http://127.0.0.1:8989

Controls: Init CA, Play/Pause, Alpha (overlay opacity). Paste points to set the
geometry layer's world->screen affine; all canvases stay edge-aligned.

```

### packages_all/Viewer24_Controller_v1/Viewer24_Controller_v1/README.md
```text

# Viewer24 Controller v1 (pure stdlib)

A 24-screen, lattice-aware viewer controller for your CQE stack. Each screen
corresponds to one of the 23 rooted Niemeier root systems plus the Leech (rootless)
context. All screens share a common world-to-screen affine so **edges are aligned**
and you get a single, uniform viewer mosaic.

## What it shows
- A 6x4 grid of canvases (24 max), with per-screen Coxeter-angle overlays derived
  from the root system components (A/D/E) of that Niemeier spec.
- Your loaded 2D points are drawn with a **single global affine** so all canvases
  share the same bounding box, centering, and scale.
- Leech screen shows no root overlay (rootless context).

## Run
```bash
python viewer_api.py
# open http://127.0.0.1:8989
```

Paste points like:
```json
[[1,0],[0,1],[-1,0],[0,-1]]
```

## Integration
- Hook coherence/collapse: call CoherenceSuite on the same points; keep the receipt.
- Hook Monster/Moonshine DB: send the embedding for nearest neighbors.
- Hook LatticeBuilder: for any screen's label, you can call the builder to get the
  block-diagonal Cartan Gram and validate properties.

## Uniform edges (design)
- The server computes a single affine (scale s, translation tx, ty) from the global
  bbox of the active point set. All 24 canvases reuse **exactly** that affine.
- Grid layout is fixed (6x4) so outer edges align perfectly. The radial Coxeter
  overlays share their center and radius, so "spokes" align visually across the grid.

## Files
- viewer_api.py            - WSGI server, APIs: /api/load, /api/screens, /api/frame
- niemeier_specs.py        - ADE Cartan builders and Niemeier spec list
- transforms.py            - global affine mapping and Coxeter angles
- static/index.html, app.js, style.css

## Roadmap
- Per-screen overlays for coherence score, delta-phi, nearest-moonshine class.
- Click-to-open details (calls CoherenceSuite and Monster/Moonshine DB).
- Multiple point layers (prev/curr) and on-canvas collapse markers.
- Timeline scrubber to navigate receipts with a unified mosaic refresh.

```

### packages_all/CoherenceSuite_v1/CoherenceSuite_v1/README.md
```text

# Coherence Suite v1 — Waveform Collapse & Decoherence (CQE-native, stdlib)

A receipts-aware toolkit to measure coherence/decoherence and detect collapse events,
aligned with your geometry-first CQE runtime and the saved embeddings.

## Modules
- coherence_metrics.py — angular/radial coherence, spectral entropy, dPhi proxy, composite score, collapse detector.
- receipts_bridge.py — unify GeoLight (.geolight/ledger.jsonl) and TokLight (.geo_tokenizer/ledger.jsonl) timelines.
- state_store.py — save/recall snapshots (points/tokens/embedding) keyed by receipt.
- callbacks.py — recall-by-receipt, pairwise comparison, timeline metrics.
- analytics_cli.py — CLI for analyses.
- api_server.py — minimal local REST API.

## Run
```bash
python api_server.py   # http://127.0.0.1:8787
```

## Examples
```bash
python analytics_cli.py coherence --points-json examples/hex.json
python analytics_cli.py collapse --prev-json ex/a.json --curr-json ex/b.json
python analytics_cli.py align --emb-a-json ex/ea.json --emb-b-json ex/eb.json
python analytics_cli.py timeline --store ./deco_states --receipts-json ex/receipts.json
```

```

### packages_all/GeometryOnlyTransformer_Standalone_v2/GeometryOnlyTransformer_Standalone_v2/README.md
```text

# Geometry-Only Transformer — Standalone v2

Pure-stdlib, no third-party deps. Includes:
- Geometry-native attention stack (no token IDs, just points and angles).
- Ledgered content-addressed compute (GeoLight) with Merkle verification.
- Channels 3/6/9 + ΔΦ guard hooks for governance-style operation.
- Demos: polygon completion, symmetry inference, curve extrapolation, hex tiling.

## Run
```bash
python geometry_transformer_standalone_v2.py --demo all
python geometry_transformer_standalone_v2.py --demo polygon --n 8 --k 3 --layers 4
python geometry_transformer_standalone_v2.py --demo curve --layers 2
```

```

### packages_all/Morphonic-LambdaSuite_v1/Morphonic-LambdaSuite_v1/README.md
```text
# Morphonic Lambda Suite v1

See docs/MGLC_Spec_v1.0.md for the formal spec.
```

### packages_all/cqe_speedlight_miner_cqe_only/cqe_speedlight_miner2/README.md
```text
CQE-only miner scaffold

```

### packages_all/cqe_speedlight_miner_mvp/cqe_speedlight_miner/README.md
```text
# CQE–Speedlight Solo Miner (MVP)

Receipts‑first, geometry‑native solo miner scaffold:
- Deterministic tri‑rail scheduler (nonce, extra‑nonce→merkle class, version/time) with dihedral palindromes
- Long‑poll GBT (with polling fallback), submitblock
- Midstate planner (reference) + reuse ratio telemetry
- O8→E8/24D atlas (simple embed) + Q‑meter (tip entropy, reorg estimate, obs lag, receipt density)
- E8 tiler (residue‑class partitioner) for multi‑agent non‑overlap
- JSONL receipts + hourly Merkle anchors
- Pure stdlib (no third‑party deps)

> This is a reference MVP for testing and extension. It does **not** change PoW or Bitcoin consensus. It reduces waste and adds auditability.

## Quickstart

```bash
python -m cqe_speedlight_miner.cli --help
# Example (regtest, localhost bitcoind RPC):
python -m cqe_speedlight_miner.cli mine --rpc-url http://127.0.0.1:18443 --rpc-user user --rpc-pass pass --address bcrt1q...
```

## Layout
- `node_adapter.py` JSON‑RPC GBT/submit wrappers (+ long‑poll)
- `header_space.py` legal rails + state mutations
- `golden_strider.py` palindromic stride sequences
- `midstate_planner.py` header construction + reuse telemetry
- `e8_tiler.py` non‑overlap agent partitioning
- `atlas_o8.py` orbital extractor + simple E8/24D mapping + curvature
- `qmeter.py` uncertainty index from headers
- `receipts.py` WHAT+GOV writer + rolling merkle anchor
- `runner.py` mining loop
- `cli.py` argparse CLI
- `tests/` minimal smoke tests
- `scripts/` regtest helpers

## Config hints
- Export `BITCOIN_RPC_URL`, `BITCOIN_RPC_USER`, `BITCOIN_RPC_PASS` or pass as flags.
- Set `--finality 6` for Q‑meter finality depth.
- Use `--agents 4 --agent-id 0..3` to split work across local processes (E8 tiler ensures non‑overlap).

## License
MIT

```

### packages_all/morphonic_chainstack/morphonic_chainstack/README.md
```text

# Morphonic Chainstack (Node + Knots + Solo Pool + Stratum V2 + Miner)

This compose stack spins up:
- **bitcoind** (Bitcoin Core) for canonical RPC and P2P
- **bitcoin-knots** (alternate client) for diversity
- **ckpool** for **solo** Stratum v1 mining (miners connect to port 3333)
- **stratumv2** server (SRI) for modern pool protocol research (port 3334)
- **morphonic-miner** sidecar (receipts-first background miner)

## Usage

1) Install Docker & docker-compose.
2) Export env creds:
```
export BTC_RPC_USER=rpcuser
export BTC_RPC_PASS=rpcpass
export PAYOUT_SCRIPT_HEX=76a914000000000000000000000000000000000000000088ac
```
3) Bring it up:
```
docker compose up -d --build
docker compose logs -f
```
- point ASICs or software miners to `stratum+tcp://<host>:3333` (CKPool solo)
- Stratum V2 server listens on `:3334` (adjust entrypoint flags as needed)

## Notes
- CKPool will build from source; if the upstream moves, update the Dockerfile repo URL.
- The Stratum V2 server entrypoint may require flags matching your topology; see the SRI docs.
- The morphonic-miner container auto-detects your SpeedLight and transformer if baked in.

```

### packages_all/morphonic_miner_full/morphonic_miner_full/README.md
```text

# Morphonic Miner — Full System (SegWit‑aware, receipts‑first, lanes, cache‑ready)

This is a complete, runnable background solo‑miner/assembler that:
- polls `getblocktemplate`, assembles **coinbase + mempool txs**,
- handles **SegWit witness commitment** (either uses GBT's `default_witness_commitment` or computes it),
- prehashes the 76‑byte header prefix for faster hashing in Python,
- explores nonces in **lanes** (8 by default; morphonic transform supported if your module is available),
- writes JSONL **receipts** for every slice and every found candidate,
- integrates with **SpeedLight** cache if `speedlight_sidecar.py` is on your PYTHONPATH (automatic fallback otherwise).

## Install & Run
1) Unzip next to this README. Ensure Python 3.10+.
2) Export env vars (example):
```
export BTC_RPC_USER=rpcuser
export BTC_RPC_PASS=rpcpass
export BTC_RPC_HOST=127.0.0.1
export BTC_RPC_PORT=8332
export PAYOUT_SCRIPT_HEX=76a914000000000000000000000000000000000000000088ac
export MM_USE_MEMPOOL=1
export MM_USE_SEGWIT=1
export NONCES_PER_SLICE=20000
export SLEEP_BETWEEN_SLICES=0.25
export MM_LANES=8
```
3) Run:
```
python -m morphonic_miner.run_miner
```

## Notes on correctness
- When `MM_USE_SEGWIT=1`, the assembler will include/compute the **witness commitment** and place it in the coinbase output (OP_RETURN). The coinbase includes a 32‑byte witness reserved value in its witness stack. The wtxid merkle root is built from the coinbase wtxid and all included tx wtxids (GBT's `transactions[].hash` when present). If the template supplies `default_witness_commitment`, we will use it directly; otherwise we compute it.
- If you prefer a minimal, fee‑less mode, set `MM_USE_MEMPOOL=0` and it will mine a coinbase‑only block (still valid, simpler).

## Receipts
Receipts go to `./miner_receipts.jsonl` (override with `MM_RECEIPTS`). Each slice records:
- template boundary conditions (height, prev, bits, curtime),
- merkle/witness roots,
- best hash observed and bits,
- lane id, nonces tried,
- tx count, coinbase txid,
- submit result if a candidate meets target.

## Service (systemd example)
Edit `systemd/morphonic-miner.service` with your paths and credentials, then:
```
mkdir -p ~/.config/systemd/user
cp systemd/morphonic-miner.service ~/.config/systemd/user/
systemctl --user daemon-reload
systemctl --user enable --now morphonic-miner.service
journalctl --user -u morphonic-miner -f
```

```

### checkpoint_v1_0/README.txt
```text

CQE Universal Checkpoint v1.0 (stdlib-only)

What you get
- Kernel (receipts-first) + sidecar placeholder (drop in your SpeedLightPlus)
- Mint Engine with: Instant-Deny Harm Gate; Tier-Down + Local-24; Emergent Coins; Education-only override
- Licensing (HMAC dev caps; swap with Ed25519 when ready)
- HTTP server exposing /mint/score, /kernel/*, /licenses/*
- Lab UI (web/ca.html): Mint Composer, Local-24 hint, Licenses tools

Run it
1) In one terminal:  python -c "from commonsledger_server.server import run; run()"
2) Open web/ca.html in your browser (the UI calls http://127.0.0.1:8765)
3) Try Run Mint / Issue Dev Token / Verify

Receipts
- .ledger/mints.jsonl     (minting results)
- .ledger/kernel.jsonl    (kernel tail)
- .secrets/license_key.txt (local HMAC secret for demo caps)

Swap-ins
- Replace sidecar/speedlight_sidecar_plus.py with your real file (same name) to wire SpeedLightPlus.
- Plug your GeoTokenizer/MDHG/Moonshine adapters behind the scenes feeding the features vectors.

```

### packages_all/cqe_speedlight_miner_mvp/cqe_speedlight_miner/LICENSE
```text
MIT License

```

### packages_all/Morphonic-CQE-Unified-Build_v1/Morphonic-CQE-Unified-Build_v1/pyproject.toml
```text

[build-system]
requires = ["setuptools>=65"]
build-backend = "setuptools.build_meta"

[project]
name = "morphonic-cqe-unified"
version = "1.0.0"
description = "Unified build of Morphonic/CQE core, sidecar, apps, and experiments"
authors = [{name="Unification Attempt", email="noreply@example.org"}]
readme = "README_UNIFIED.md"
requires-python = ">=3.10"
classifiers = ["Programming Language :: Python :: 3"]

[project.scripts]
cqe-personal-node = "morphonic_cqe_unified.apps.cqe_personal_node:main"

[tool.setuptools.packages.find]
where = ["."]

```
