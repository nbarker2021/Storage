diff --git a/lattice_ai/bridge/config.py b/lattice_ai/bridge/config.py\nnew file mode 100644\nindex 0000000..40aabfe\n--- /dev/null\n+++ b/lattice_ai/bridge/config.py\n@@ -0,0 +1,14 @@\n+\n+from __future__ import annotations\n+import os\n+\n+# Dual-stack configuration via environment variables:\n+# E8_DUAL_MODE: "v14", "legacy", or "shadow" (shadow runs both and compares)\n+# E8_LEGACY_IMPORT: path hint for legacy module root if non-standard\n+# E8_SNAP_COMPARE: "1" to emit a SNAP manifest for comparison results (requires e8snap)\n+# E8_SNAP_KIND: manifest kind (default "Run")\n+\n+MODE = os.getenv("E8_DUAL_MODE", "v14").lower()\n+LEGACY_HINT = os.getenv("E8_LEGACY_IMPORT", "").strip()\n+SNAP_COMPARE = os.getenv("E8_SNAP_COMPARE", "0") == "1"\n+SNAP_KIND = os.getenv("E8_SNAP_KIND", "Run")\n\ndiff --git a/lattice_ai/bridge/dual_stack.py b/lattice_ai/bridge/dual_stack.py\nnew file mode 100644\nindex 0000000..a6cd313\n--- /dev/null\n+++ b/lattice_ai/bridge/dual_stack.py\n@@ -0,0 +1,158 @@\n+\n+from __future__ import annotations\n+import importlib\n+import json\n+from dataclasses import dataclass\n+from typing import Any, Tuple, Optional, Dict\n+import numpy as np\n+\n+from .config import MODE, LEGACY_HINT, SNAP_COMPARE, SNAP_KIND\n+\n+def _try_import(module: str):\n+    try:\n+        return importlib.import_module(module)\n+    except Exception:\n+        return None\n+\n+def _import_v14():\n+    mod_roots = _try_import("lattice_ai.geometry.e8_roots")\n+    mod_geo = _try_import("lattice_ai.geometry.e8")\n+    return mod_roots, mod_geo\n+\n+def _import_legacy():\n+    # optional hint for non-standard package path\n+    if LEGACY_HINT:\n+        try:\n+            import sys\n+            if LEGACY_HINT not in sys.path:\n+                sys.path.insert(0, LEGACY_HINT)\n+        except Exception:\n+            pass\n+    # Try known legacy paths\n+    candidates = [\n+        ("lattice_system_base_v14.lattice_ai.geometry.e8_roots", "lattice_system_base_v14.lattice_ai.geometry.e8"),\n+        ("lattice_system_base_v12.lattice_system_base_v12.lattice_ai.geometry.e8_roots", "lattice_system_base_v12.lattice_system_base_v12.lattice_ai.geometry.e8"),\n+        ("lattice_system_base_v10.lattice_system_base_v10.lattice_ai.geometry.e8_roots", "lattice_system_base_v10.lattice_system_base_v10.lattice_ai.geometry.e8"),\n+    ]\n+    for r, g in candidates:\n+        mr = _try_import(r)\n+        mg = _try_import(g)\n+        if mr and mg:\n+            return mr, mg\n+    return None, None\n+\n+@dataclass\n+class E8APIs:\n+    roots_mod: Any\n+    geo_mod: Any\n+\n+    def generate_roots(self) -> np.ndarray:\n+        return self.roots_mod.generate_e8_roots()\n+\n+    def simple_roots(self) -> np.ndarray:\n+        return self.roots_mod.standard_simple_roots()\n+\n+    def build(self):\n+        return self.roots_mod.E8.build()\n+\n+    def reflect(self, V: np.ndarray, r: np.ndarray) -> np.ndarray:\n+        g = self.geo_mod.E8Geometry()\n+        return g.reflect(V, r)\n+\n+def load_api_set(kind: str) -> Optional[E8APIs]:\n+    if kind == "v14":\n+        r, g = _import_v14()\n+    else:\n+        r, g = _import_legacy()\n+    if r is None or g is None:\n+        return None\n+    return E8APIs(r, g)\n+\n+def _roughly_equal_roots(A: np.ndarray, B: np.ndarray, tol: float = 1e-6) -> bool:\n+    if A.shape != B.shape:\n+        return False\n+    # Compare sorted rows for approximate equality\n+    Ax = np.sort(A.round(6), axis=0)\n+    Bx = np.sort(B.round(6), axis=0)\n+    return np.allclose(Ax, Bx, atol=tol)\n+\n+def _neighbor_degrees(e8_obj) -> np.ndarray:\n+    R, nbrs = e8_obj.neighbor_graph()\n+    return np.array([len(n) for n in nbrs], dtype=int)\n+\n+def compare_sets(v14: E8APIs, legacy: E8APIs) -> Dict[str, Any]:\n+    out: Dict[str, Any] = {}\n+    R14 = v14.generate_roots()\n+    RL = legacy.generate_roots()\n+    out["roots_same_shape"] = tuple(R14.shape) == tuple(RL.shape)\n+    out["roots_approx_equal"] = _roughly_equal_roots(R14, RL)\n+    out["root_norms_v14_mean"] = float(np.mean(np.sum(R14*R14, axis=1)))\n+    out["root_norms_legacy_mean"] = float(np.mean(np.sum(RL*RL, axis=1)))\n+\n+    e14 = v14.build()\n+    el = legacy.build()\n+    deg14 = _neighbor_degrees(e14)\n+    degl = _neighbor_degrees(el)\n+    out["deg_same_len"] = len(deg14) == len(degl)\n+    out["deg_mean_v14"] = float(np.mean(deg14))\n+    out["deg_mean_legacy"] = float(np.mean(degl))\n+    out["deg_dist_close"] = abs(out["deg_mean_v14"] - out["deg_mean_legacy"]) < 1e-3\n+\n+    # Reflection involution check on a small sample\n+    r0 = R14[0]\n+    V = R14[:5]\n+    V_ref14 = v14.reflect(V, r0)\n+    V_back14 = v14.reflect(V_ref14, r0)\n+    out["reflect_involution_v14"] = bool(np.allclose(V, V_back14))\n+\n+    r0L = RL[0]\n+    VL = RL[:5]\n+    V_refL = legacy.reflect(VL, r0L)\n+    V_backL = legacy.reflect(V_refL, r0L)\n+    out["reflect_involution_legacy"] = bool(np.allclose(VL, V_backL))\n+\n+    return out\n+\n+def load_dual() -> Tuple[E8APIs, Optional[E8APIs], Optional[Dict[str, Any]]]:\n+    v14 = load_api_set("v14")\n+    if v14 is None:\n+        raise ImportError("Failed to import v14 E8 geometry.")\n+    legacy = None\n+    report = None\n+    if MODE == "legacy":\n+        legacy = load_api_set("legacy")\n+        if legacy is None:\n+            raise ImportError("Failed to import legacy E8 geometry.")\n+        return legacy, None, None\n+    if MODE == "shadow":\n+        legacy = load_api_set("legacy")\n+        if legacy:\n+            report = compare_sets(v14, legacy)\n+    return v14, legacy, report\n+\n+def maybe_emit_snap(report: Dict[str, Any], axes: Dict[str, Any], e8_obj: Optional[Dict[str, Any]] = None) -> None:\n+    if not SNAP_COMPARE or not report:\n+        return\n+    try:\n+        from e8snap.snap_writer import write_manifest, now_iso\n+        manifest = {\n+            "schema_version": "2.0",\n+            "snap_id": "compare:e8-dual-shadow",\n+            "created_at": now_iso(),\n+            "e8": e8_obj or {"version":"0.1","coords":[1,0,0,0,0,0,0,0],\n+                             "root_loc":{"nearest_roots":[{"index":0,"inner_product":1.0}],\n+                                         "reflections":[],"adjacency_rule":"inner_product_eq_1"},\n+                             "axes": axes},\n+            "axes": axes,\n+            "kind": SNAP_KIND,\n+            "metrics": report,\n+            "provenance": {"code_version": axes.get("version_container","v14"),\n+                           "modules":["lattice_ai.bridge.dual_stack"]},\n+            "payload": {"format":"json","location":"snaps/reports/e8_dual_shadow.json","size_bytes":0,"secure":True},\n+        }\n+        out = pathlib.Path("snaps/reports/e8_dual_shadow.json")\n+        out.parent.mkdir(parents=True, exist_ok=True)\n+        write_manifest(manifest, out)\n+    except Exception:\n+        # Best-effort only\n+        pass\n\ndiff --git a/tools/run_dual_compare.py b/tools/run_dual_compare.py\nnew file mode 100644\nindex 0000000..9cb9301\n--- /dev/null\n+++ b/tools/run_dual_compare.py\n@@ -0,0 +1,17 @@\n+\n+from __future__ import annotations\n+import json\n+from pathlib import Path\n+from lattice_ai.bridge.dual_stack import load_dual, maybe_emit_snap\n+\n+def main() -> None:\n+    v14, legacy, report = load_dual()\n+    print("Loaded v14:", bool(v14))\n+    print("Loaded legacy:", bool(legacy))\n+    if report:\n+        print(json.dumps(report, indent=2))\n+        axes = {"version_container": "v14", "tenant": "demo", "domain": "geometry"}\n+        maybe_emit_snap(report, axes)\n+\n+if __name__ == "__main__":\n+    main()\n\ndiff --git a/tests/test_dual_stack_geometry.py b/tests/test_dual_stack_geometry.py\nnew file mode 100644\nindex 0000000..6c9fbd3\n--- /dev/null\n+++ b/tests/test_dual_stack_geometry.py\n@@ -0,0 +1,6 @@\n+\n+from lattice_ai.bridge.dual_stack import load_dual\n+\n+def test_dual_loads_v14():\n+    v14, legacy, report = load_dual()\n+    assert v14 is not None\n\ndiff --git a/docs/README_bridge.md b/docs/README_bridge.md\nnew file mode 100644\nindex 0000000..9fed610\n--- /dev/null\n+++ b/docs/README_bridge.md\n@@ -0,0 +1,18 @@\n+\n+# Dual-Stack Bridge (v14 + Legacy)\n+\n+This package ties **v14** and **legacy (v8–v12)** E8 geometry implementations together.\n+\n+- **Modes (env `E8_DUAL_MODE`)**\n+  - `v14` (default): use v14 APIs.\n+  - `legacy`: force legacy APIs.\n+  - `shadow`: run v14 and legacy in parallel and compare (root shapes, norms, neighbor degrees, reflection involutions).\n+\n+- **Emit comparison SNAP**\n+  - Set `E8_SNAP_COMPARE=1` to write a SNAP v2 manifest with comparison metrics (requires `e8snap` package).\n+  - Output path: `snaps/reports/e8_dual_shadow.json`.\n+\n+- **CLI**\n+  - `python -m tools.run_dual_compare` — prints comparison report; writes SNAP if enabled.\n+\n+Integrate this bridge early, and incrementally port modules to v14 while keeping legacy parity checks.\n