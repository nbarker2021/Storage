""" UVIBS Core — single‑file scaffold with formulaic methods
This module implements a minimal, math‑first UVIBS engine suitable for plugging behind any LLM to create a “custom GPT” that reasons by legal gates.
It includes: • E8 geometry (Cartan Gram) and an 80D spine (E8×10) • Windows (rests): W4, W80 (global/strict), and parametric Expansion Wexp(p, ν | 8) • Gates: PAL_b, MIRROR(m, b), Mirror‑CRT • Governance: 24D projections, Monster legality, Alena weights, and repair (AMP) • Transforms: fold / split / shear + Monster‑aware wrapper • Controller: a routing loop with Crooks‑style bookkeeping • Logging helpers + a tiny relations DSL
All checks are O(D). Governance repair acts on a fixed +8 DOF control block, bounded iterations. Docstrings include the exact formulas.
Dependencies: numpy, pandas (for logs). No external solvers required.
Author: (you) License: MIT """ from future import annotations
from dataclasses import dataclass, field from typing import Callable, Dict, Iterable, List, Optional, Sequence, Tuple import math import hashlib import csv from pathlib import Path
import numpy as np import pandas as pd
=============================
Section 0 — Utilities & Math
=============================
def lcm(a: int, b: int) -> int: """Least common multiple.""" return abs(a*b) // math.gcd(a, b) if a and b else 0
def crt_pair(rm: Tuple[int,int], rn: Tuple[int,int]) -> Optional[Tuple[int,int]]: """Chinese Remainder join of two congruences.
Given (x ≡ r_m (mod m)), (x ≡ r_n (mod n)), return (R, M) with x ≡ R (mod M), if compatible; else None. Compatibility: (r_m − r_n) % gcd(m,n) == 0. Reference formula: let g = gcd(m,n), m' = m//g, n' = n//g. Find t such that t ≡ (r_n − r_m)/g (mod n'). Then R = r_m + m * t. Return R mod M, where M = lcm(m,n). """ r_m, m = rm r_n, n = rn g = math.gcd(m, n) if (r_m - r_n) % g != 0: return None M = lcm(m, n) if M == 0: return (0, 0) # Solve m * t ≡ (r_n − r_m) (mod n) divided by g m1, n1 = m // g, n // g rhs = (r_n - r_m) // g # Compute inverse of m1 mod n1 if coprime; if not, n1==1 in compatible cases try: inv_m1 = pow(m1, -1, n1) if n1 > 1 else 0 except ValueError: return None t = (rhs * inv_m1) % n1 if n1 > 1 else 0 R = (r_m + m * t) % M return (R, M) 
def crt_meet_many(pairs: Sequence[Tuple[int,int]]) -> Optional[Tuple[int,int]]: """Iteratively fold a list of congruences via CRT. Return (R, M) or None.""" if not pairs: return (0, 1) R, M = pairs[0] for rn in pairs[1:]: out = crt_pair((R, M), rn) if out is None: return None R, M = out return (R, M)
======================================
Section 1 — E8 Geometry & Quad. Forms
======================================
def cartan_e8() -> np.ndarray: """Return the 8×8 Cartan Gram matrix for E8.
The simply‑laced Cartan form (2 on diag, −1 on edges of the Dynkin diagram): Edges: (0–1), (1–2), (2–3), (3–4), (4–5), (5–6), and branch (2–7) """ G = np.zeros((8, 8), dtype=int) for i in range(8): G[i, i] = 2 for i, j in [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(2,7)]: G[i, j] = G[j, i] = -1 return G 
def gram_block_e8xk(k: int) -> np.ndarray: """Block‑diagonal Gram: diag(G_E8, ..., G_E8) with k blocks (D = 8k).""" G8 = cartan_e8() return np.kron(np.eye(k, dtype=int), G8)
def quad_form(v: np.ndarray, G: np.ndarray, mod: Optional[int] = None) -> int: """Quadratic form Q(v) = vᵀ G v (optionally reduced mod m).""" q = int(v.T @ (G @ v)) return q % mod if mod is not None else q
=============================
Section 2 — Windows (Rests)
=============================
def window_W4(v: np.ndarray) -> bool: """W4 (parity rest): ∑ v ≡ 0 (mod 4).""" return int(np.sum(v)) % 4 == 0
def window_W80(v: np.ndarray, G80: np.ndarray, strict_perblock: bool = False) -> bool: """W80 (codec rest): octadic neutrality + E8 doubly‑even parity.
Conditions: 1) ∑ v ≡ 0 (mod 8) 2) Q(v) ≡ 0 (mod 4) [global], or per‑block: for each 8‑slice v_b, v_bᵀ G_E8 v_b ≡ 0 (mod 4) Per‑block ⇒ global. Global does not imply per‑block. """ s = int(np.sum(v)) if s % 8 != 0: return False if not strict_perblock: return quad_form(v, G80, mod=4) == 0 # strict: check each block G8 = cartan_e8() for start in range(0, len(v), 8): vb = v[start:start+8] if quad_form(vb, G8, mod=4) != 0: return False return True 
def window_Wexp(v: np.ndarray, G80: np.ndarray, p: int, nu: int, *, bridge: bool=False) -> bool: """Parametric expansion window Wexp(p, ν | 8).
Definition: Wexp(p, ν|8) := { v : Q(v) ≡ 0 (mod p) and ∑ v ≡ 0 (mod ν) } If bridge=True, additionally require ∑ v ≡ 0 (mod lcm(8, ν)). Examples: classic 7/72: p=7, ν=9 (lcm(8,9)=72) φ‑lane 11/40: p=11, ν=10 (lcm(8,10)=40) """ if quad_form(v, G80, mod=p) != 0: return False s = int(np.sum(v)) if s % nu != 0: return False if bridge: if s % lcm(8, nu) != 0: return False return True 
=================================
Section 3 — PAL / MIRROR Gates
=================================
def pal_ok(window: np.ndarray) -> bool: """Exact palindrome test for a 1D integer window.""" return np.array_equal(window, window[::-1])
def mirror_ok(window: np.ndarray, base: int, m: int) -> bool: """Mirror congruence: x ≡ rev_b(x) (mod m).
Numerically interpret the window as base‑b digits. For even length, one typically also has divisibility by (b+1) in many cases; choose m accordingly. """ x = 0 y = 0 for d in window: x = (x * base + int(d)) % m for d in window[::-1]: y = (y * base + int(d)) % m return (x - y) % m == 0 
def mirror_crt_ok(window: np.ndarray, base: int, moduli: Sequence[int]) -> bool: """Check Mirror for multiple moduli via CRT compatibility.""" pairs = [] for m in moduli: # The residue (x - rev_b(x)) mod m should be 0 for Mirror; encode as (0, m) if not mirror_ok(window, base, m): return False pairs.append((0, m)) # CRT of (0 mod m_i) is always (0, lcm(...)) if moduli are pairwise compatible return crt_meet_many(pairs) is not None
======================================
Section 4 — Governance (24D Monster)
======================================
def build_projection_map(kind: str, D: int) -> np.ndarray: """Return a projection map Π: {0..D-1} → {0..23} as an integer array.
kind ∈ {"mod24", "shift_12", "affine_5i7"} """ if kind == "mod24": return np.arange(D, dtype=int) % 24 if kind == "shift_12": return (np.arange(D, dtype=int) + 12) % 24 if kind == "affine_5i7": return (5 * np.arange(D, dtype=int) + 7) % 24 raise ValueError(f"Unknown projection kind: {kind}") 
def project24(v: np.ndarray, pmap: np.ndarray) -> np.ndarray: """Aggregate 80D → 24D by slot accumulation: (Π v)k = sum{i:Π(i)=k} v_i.""" out = np.zeros(24, dtype=int) for i, slot in enumerate(pmap): out[slot] += int(v[i]) return out
def gram_24() -> np.ndarray: """A 24D Gram as E8×3 block‑diag (Niemeier E8^3), sufficient for parity/isotropy tests.""" G8 = cartan_e8() return np.kron(np.eye(3, dtype=int), G8)
def governance_ok(v: np.ndarray, pmap: np.ndarray) -> bool: """Monster legality on a single 24D projection.
Let u = Π(v) ∈ Z^{24}. Check per‑block E8 mod‑4 on the three 8‑slices of u and total isotropy mod 7 using G24 = diag(G_E8, G_E8, G_E8). Conditions: For each block u_b: u_bᵀ G_E8 u_b ≡ 0 (mod 4) Total: uᵀ G24 u ≡ 0 (mod 7) """ u = project24(v, pmap) G8 = cartan_e8() for start in range(0, 24, 8): ub = u[start:start+8] if quad_form(ub, G8, mod=4) != 0: return False G24 = gram_24() return quad_form(u, G24, mod=7) == 0 
def governance_joint(v: np.ndarray, pmaps: Sequence[np.ndarray]) -> bool: """Intersection legality across several projections.""" return all(governance_ok(v, p) for p in pmaps)
def AMP_repair_to_governance(v: np.ndarray, pmaps: Sequence[np.ndarray], control_block: Tuple[int,int] = (40, 48), max_steps: int = 100, step_size: int = 1) -> Optional[np.ndarray]: """Alternating modular projections (AMP) repair.
Try to adjust only the +8 DOF control block indices in [i0, i1) to satisfy Monster legality across all pmaps. Greedy search with bounded steps: for each projection, if illegal, try ±step_size tweaks on control coords to reduce violations and re‑test previously satisfied projections. Returns a repaired copy of v or None if budget exceeded. """ i0, i1 = control_block out = v.copy() def ok_all(vec): return all(governance_ok(vec, p) for p in pmaps) if ok_all(out): return out # coordinate list in control block idxs = list(range(i0, i1)) for _ in range(max_steps): improved = False for p in pmaps: if governance_ok(out, p): continue # Try small local nudges for j in idxs: for delta in (+step_size, -step_size): out[j] += delta if governance_ok(out, p) and all(governance_ok(out, q) for q in pmaps): improved = True break out[j] -= delta if improved: break if improved: break if improved and ok_all(out): return out return None 
============================
Section 5 — Alena Weights
============================
def hash_to_theta(seed: str) -> float: """Map an arbitrary string to θ ∈ [0,1) via SHA256.""" h = hashlib.sha256(seed.encode()).hexdigest() # take first 8 hex chars as integer x = int(h[:8], 16) return (x % 10_000_000) / 10_000_000.0
def make_alena_weights(n_slots: int, theta: float) -> np.ndarray: """Alena 24‑slot cosine weights: w_j = 0.5 * (1 + cos(2π(θ + j/φ)))
φ = (1+√5)/2 is used for mild incommensurability. """ phi = (1 + 5 ** 0.5) / 2 js = np.arange(n_slots) return 0.5 * (1.0 + np.cos(2 * np.pi * (theta + js / phi))) 
def shell_weight(v: np.ndarray, *, shell: str = "octad") -> float: """Shell gauge: triad/pentad/octad based on sum(v) residue.
triad: w = W3[sum % 3]\n pentad: w = W5[sum % 5]\n octad: w = W8[sum % 8] """ s = int(np.sum(v)) if shell == "triad": W3 = np.array([1.0, 0.9, 1.1]) return float(W3[s % 3]) if shell == "pentad": W5 = np.array([1.0, 0.95, 1.05, 0.95, 1.0]) return float(W5[s % 5]) # default octad W8 = np.array([1.0, 0.96, 1.02, 0.98, 1.04, 0.98, 1.02, 0.96]) return float(W8[s % 8]) 
def alena_weight(v: np.ndarray, W24: np.ndarray) -> float: """Multiply Alena weights by 24‑slot projection sum index: index = (sum(v) mod 24).""" idx = int(np.sum(v)) % len(W24) return float(W24[idx])
================================
Section 6 — Transforms (Legal)
================================
def fold(v: np.ndarray) -> np.ndarray: """Fold: for i in {0,2,4,...}: v_i ← v_i + v_{i+1}, v_{i+1} ← 0.""" out = v.copy() for i in range(0, len(out), 2): j = i + 1 if j < len(out): out[i] += out[j] out[j] = 0 return out
def split(v: np.ndarray, *, offset: int = 7) -> np.ndarray: """Split with offset o (default 7): Find first i with |v_i| ≥ 2. Write v_i = a + b with a = floor(v_i/2), b = v_i − a, set v_i ← a, and v_{(i+o) mod D} += b. """ out = v.copy() D = len(out) for i in range(D): if abs(out[i]) >= 2: a = out[i] // 2 b = out[i] - a out[i] = a out[(i + offset) % D] += b return out # nothing to split → nudge smallest‑magnitude coord k = int(np.argmin(np.abs(out))) out[(k + offset) % D] += 1 out[k] -= 1 return out
def shear(v: np.ndarray) -> np.ndarray: """Shear: v_i ← v_i + v_{(i+1) mod D} (use sparingly).""" out = v.copy() D = len(out) nxt = np.roll(out, -1) out += nxt return out
def monster_aware_transform(v: np.ndarray, pmaps: Sequence[np.ndarray], *, base_op: str = "fold", control_block: Tuple[int,int] = (40,48), max_steps: int = 100) -> Optional[np.ndarray]: """Apply base op ∈ {fold, split, shear} then repair to governance (AMP). Accept only if post‑state lies in every active projection legality set. """ if base_op == "fold": w = fold(v) elif base_op == "split": w = split(v) elif base_op == "shear": w = shear(v) else: raise ValueError("base_op must be fold|split|shear") repaired = AMP_repair_to_governance(w, pmaps, control_block=control_block, max_steps=max_steps) return repaired
==============================
Section 7 — Metrics & Crooks
==============================
def weighted_capacity(vectors: Iterable[np.ndarray], *, W24: Optional[np.ndarray] = None, shell: str = "octad", governance_masks: Optional[Iterable[bool]] = None, regime: str = "alena_monster") -> float: """Weighted capacity μ_W over a set of vectors that already pass a given window.
baseline: w = w_shell alena: w = w_shell * w_alena alena_monster: same as alena; but you should prefilter to governance. """ mu = 0.0 for i, v in enumerate(vectors): if governance_masks is not None: g = list(governance_masks)[i] if not g: continue ws = shell_weight(v, shell=shell) if regime == "baseline": w = ws elif regime in ("alena", "alena_monster") and W24 is not None: w = ws * alena_weight(v, W24) else: w = ws mu += float(w) return mu 
def entropy(mu: float) -> float: return float(np.log(mu)) if mu > 0 else float("-inf")
def crooks_ratio(delta_S: float) -> float: """P_rev / P_fwd = exp(-ΔS).""" return float(np.exp(-delta_S))
=====================================
Section 8 — Controller (Routing Loop)
=====================================
@dataclass class ExpansionSpec: p: int nu: int bridge: bool = False
@dataclass class RouteConfig: D: int = 80 strict_perblock: bool = False base: int = 10 mirror_mods: Tuple[int, ...] = (9, 10, 8) # divisors of (b−1) plus 8‑partner exp: ExpansionSpec = field(default_factory=lambda: ExpansionSpec(7, 9, False)) phi_on: bool = False projections: Tuple[str, ...] = ("mod24", "affine_5i7") control_block: Tuple[int, int] = (40, 48) max_repair_steps: int = 100
class UVIBSController: """Routing engine with governance and windows.
Usage: ctrl = UVIBSController(RouteConfig(...)) v' , logs = ctrl.route_once(v) """ def __init__(self, cfg: RouteConfig): self.cfg = cfg self.G80 = gram_block_e8xk(cfg.D // 8) self.pmaps = [build_projection_map(k, cfg.D) for k in cfg.projections] if cfg.phi_on: self.cfg.exp = ExpansionSpec(11, 10, False) # ---------- Formulaic methods for windows & gates ---------- def passes_W4(self, v: np.ndarray) -> bool: return window_W4(v) def passes_W80(self, v: np.ndarray) -> bool: return window_W80(v, self.G80, strict_perblock=self.cfg.strict_perblock) def passes_Wexp(self, v: np.ndarray) -> bool: e = self.cfg.exp return window_Wexp(v, self.G80, e.p, e.nu, bridge=e.bridge) def passes_mirror_palette(self, window: np.ndarray) -> bool: return any(mirror_ok(window, self.cfg.base, m) for m in self.cfg.mirror_mods) def passes_governance(self, v: np.ndarray) -> bool: return governance_joint(v, self.pmaps) # ---------- Small repairs ---------- def repair_W4(self, v: np.ndarray) -> Optional[np.ndarray]: if self.passes_W4(v): return v out = v.copy() # adjust inside control block to fix sum mod 4 target = (-int(np.sum(out))) % 4 i0, i1 = self.cfg.control_block out[i0] += target return out if self.passes_W4(out) else None def repair_governance(self, v: np.ndarray) -> Optional[np.ndarray]: return AMP_repair_to_governance(v, self.pmaps, control_block=self.cfg.control_block, max_steps=self.cfg.max_repair_steps) # ---------- Transforms ---------- def apply_monster_aware(self, v: np.ndarray, base_op: str) -> Optional[np.ndarray]: return monster_aware_transform(v, self.pmaps, base_op=base_op, control_block=self.cfg.control_block, max_steps=self.cfg.max_repair_steps) # ---------- Routing ---------- def route_once(self, v: np.ndarray, *, base_op_order: Tuple[str, ...] = ("fold","split")) -> Tuple[Optional[np.ndarray], Dict]: """One legal hop with logs. Algorithm: 0) Gate prefilter (mirror/pal) is caller’s responsibility when proposing a window. 1) Ensure W4 (repair if needed). 2) governance repair. 3) Choose direct vs expansion route. 4) Close at a rest (W80 or W4) and compute simple deltas (placeholders for full μ/S accounting). """ logs = {"strict": self.cfg.strict_perblock, "exp": (self.cfg.exp.p, self.cfg.exp.nu, self.cfg.exp.bridge)} x = v.copy() # 1) W4 if not self.passes_W4(x): x_repaired = self.repair_W4(x) if x_repaired is None: logs["deny"] = "W4_FAIL" return None, logs x = x_repaired # 2) Governance pre‑check if not self.passes_governance(x): x_g = self.repair_governance(x) if x_g is None: logs["deny"] = "GOV_FAIL" return None, logs x = x_g # 3) Route # Try direct codec first if not strict if not self.cfg.strict_perblock: for op in base_op_order: y = self.apply_monster_aware(x, op) if y is not None and self.passes_W80(y): logs["route"] = f"4→80 via {op}" return y, logs # Expansion lane for op in base_op_order: y = self.apply_monster_aware(x, op) if y is None: continue if not self.passes_Wexp(y): continue # re‑enter codec if not self.passes_W80(y): y2 = self.repair_governance(y) if y2 is None or not self.passes_W80(y2): continue y = y2 logs["route"] = f"4→exp({self.cfg.exp.p};{self.cfg.exp.nu})→80 via {op}" return y, logs logs["deny"] = "NO_ROUTE" return None, logs 
===================================
Section 9 — Relations DSL & Logs
===================================
def relation_signature(window: np.ndarray, *, base: int, primes: Sequence[int] = (7,11,13)) -> Dict: """Compute a compact signature of small relations for an 8‑window.
Includes pal flag, mirror flags for divisors of (b−1) and (b+1) (when even length), sum residues mod {2,3,4,5,8,9,10}, and QF residues over small primes when embedded. (QF part requires an 80D lift; callers can add that.) """ L = len(window) sig = { "pal": bool(pal_ok(window)), "sum_mod_2": int(np.sum(window)) % 2, "sum_mod_3": int(np.sum(window)) % 3, "sum_mod_4": int(np.sum(window)) % 4, "sum_mod_5": int(np.sum(window)) % 5, "sum_mod_8": int(np.sum(window)) % 8, "sum_mod_9": int(np.sum(window)) % 9, "sum_mod_10": int(np.sum(window)) % 10, } # Mirror flags mset = set() for d in range(2, base): if (base - 1) % d == 0: mset.add(d) if L % 2 == 0: for d in range(2, base+2): if (base + 1) % d == 0: mset.add(d) for m in sorted(mset): sig[f"mir_{m}"] = bool(mirror_ok(window, base, m)) return sig 
def write_csv(path: Path, rows: List[Dict]): if not rows: return path.parent.mkdir(parents=True, exist_ok=True) with path.open("w", newline="") as f: w = csv.DictWriter(f, fieldnames=list(rows[0].keys())) w.writeheader() for r in rows: w.writerow(r)
==================================
Section 10 — Minimal Demonstrator
==================================
def demo_build_controller(phi_on: bool = False, strict: bool = False) -> UVIBSController: """Construct a controller with common presets.
• base b=10 with mirror palette (9,10,8) • expansion: 7/9 (classic) or 11/10 (φ‑lane) depending on phi_on • strict per‑block toggle for codec """ cfg = RouteConfig( D=80, strict_perblock=strict, base=10, mirror_mods=(9, 10, 8), exp=ExpansionSpec(7, 9, False), phi_on=phi_on, projections=("mod24", "affine_5i7"), control_block=(40, 48), max_repair_steps=100, ) return UVIBSController(cfg) 
def demo_step_sequence(ctrl: UVIBSController, *, steps: int = 10) -> pd.DataFrame: """Run a few legal hops from zero state with alternating base ops.
This is a toy to prove everything is wired. For serious runs, feed real windows. """ v = np.zeros(ctrl.cfg.D, dtype=int) logs: List[Dict] = [] ops = ("fold", "split") for t in range(steps): y, info = ctrl.route_once(v, base_op_order=ops) info["t"] = t info["ok"] = y is not None logs.append(info) if y is None: break v = y return pd.DataFrame(logs) 
if name == "main": # Example: quick smoke test ctrl = demo_build_controller(phi_on=False, strict=False) df = demo_step_sequence(ctrl, steps=8) out = Path("./uvibs_demo_logs.csv") df.to_csv(out, index=False) print(f"Wrote {out}")