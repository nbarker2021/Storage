# CQE Deployment Guide

Complete guide for deploying CQE in production environments.

## Quick Deployment

### Docker Compose (Recommended for Testing)

```bash
# Clone repository
git clone https://github.com/yourusername/cqe-production.git
cd cqe-production

# Start services
docker-compose up -d

# Check health
curl http://localhost:8000/health

# View logs
docker-compose logs -f cqe-api
```

### Local Installation

```bash
# Setup environment
bash scripts/setup_env.sh
source venv/bin/activate

# Run tests
pytest

# Start API server
python -m cqe.api.rest
```

## Production Deployment

### Kubernetes

#### Prerequisites
- Kubernetes cluster (1.24+)
- kubectl configured
- Persistent storage provisioner

#### Deploy CQE

```bash
# Create namespace
kubectl create namespace cqe

# Apply configurations
kubectl apply -f deployment/kubernetes/configmap.yaml -n cqe
kubectl apply -f deployment/kubernetes/deployment.yaml -n cqe

# Check status
kubectl get pods -n cqe
kubectl get svc -n cqe

# Get external IP
kubectl get svc cqe-api -n cqe
```

#### Scale Deployment

```bash
# Manual scaling
kubectl scale deployment cqe-api --replicas=10 -n cqe

# HPA automatically scales based on CPU/memory
kubectl get hpa -n cqe
```

### Docker Standalone

```bash
# Build image
docker build -t cqe:latest .

# Run container
docker run -d \
  --name cqe-api \
  -p 8000:8000 \
  -e REDIS_URL=redis://your-redis:6379 \
  -v $(pwd)/data:/app/data \
  cqe:latest

# Check logs
docker logs -f cqe-api
```

## Configuration

### Environment Variables

```bash
# Required
REDIS_URL=redis://localhost:6379

# Optional
LOG_LEVEL=INFO                 # DEBUG, INFO, WARNING, ERROR
MAX_CACHE_SIZE=10000           # Maximum overlays in memory
MORSR_MAX_ITERATIONS=10        # MORSR optimization iterations
PHI_TOLERANCE=0.000001         # Convergence threshold
```

### Redis Configuration

For production, configure Redis with:
- Persistence (AOF or RDB)
- Maximum memory policy
- Password authentication

```redis
# redis.conf
maxmemory 2gb
maxmemory-policy allkeys-lru
requirepass your_secure_password
appendonly yes
```

## Monitoring

### Prometheus Metrics

```bash
# Deploy Prometheus
kubectl apply -f deployment/monitoring/prometheus.yml -n cqe

# Access Prometheus UI
kubectl port-forward svc/prometheus 9090:9090 -n cqe
```

**Available Metrics:**
- `cqe_embeddings_total`: Total embeddings processed
- `cqe_cache_hit_rate`: Cache hit rate
- `cqe_morsr_iterations_avg`: Average MORSR iterations
- `cqe_processing_time_seconds`: Processing time histogram

### Health Checks

```bash
# API health
curl http://localhost:8000/health

# Detailed metrics
curl http://localhost:8000/metrics
```

## Performance Tuning

### Optimization Settings

```python
# Adjust Î¦ weights for domain
phi_computer = PhiComputer(weights={
    'alpha': 1.0,    # Geometry (increase for smoothness)
    'beta': 5.0,     # Parity (increase for ECC compliance)
    'gamma': 0.5,    # Sparsity (increase for efficiency)
    'delta': 0.1     # Kissing (increase for E8 alignment)
})
```

### Cache Configuration

```python
# Large cache for high-traffic
cache = OverlayCache(
    max_size=50000,
    redis_url="redis://localhost:6379"
)
```

### MORSR Tuning

```python
# Balance optimization vs speed
morsr = MORSRProtocol(phi_computer, canonicalizer)
result = morsr.pulse_sweep(
    seed_overlay,
    max_iterations=20,        # More iterations = better optimization
    convergence_threshold=1e-6  # Tighter = more precise
)
```

## Security

### API Security

```python
# Add authentication (FastAPI)
from fastapi.security import HTTPBearer

security = HTTPBearer()

@app.post("/embed")
async def embed(request: EmbedRequest, token: str = Depends(security)):
    # Validate token
    if not validate_token(token):
        raise HTTPException(401, "Invalid token")
    # Process request
```

### Network Security

```yaml
# Kubernetes NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: cqe-api-policy
spec:
  podSelector:
    matchLabels:
      app: cqe
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector: {}
    ports:
    - protocol: TCP
      port: 8000
```

## Backup and Recovery

### Data Backup

```bash
# Backup overlays (if using persistent storage)
kubectl exec -n cqe cqe-api-xxx -- tar czf /tmp/backup.tar.gz /app/data
kubectl cp cqe/cqe-api-xxx:/tmp/backup.tar.gz ./backup-$(date +%Y%m%d).tar.gz
```

### Redis Backup

```bash
# RDB snapshot
redis-cli BGSAVE

# Export to file
redis-cli --rdb dump.rdb
```

## Troubleshooting

### Common Issues

**Issue: High memory usage**
```bash
# Check cache size
curl http://localhost:8000/cache

# Reduce max_cache_size in environment
```

**Issue: Slow embeddings**
```bash
# Reduce MORSR iterations
export MORSR_MAX_ITERATIONS=5

# Disable optimization for speed
overlay = client.embed(text, optimize=False)
```

**Issue: Redis connection errors**
```bash
# Check Redis connectivity
redis-cli -h redis-host -p 6379 ping

# Verify REDIS_URL environment variable
echo $REDIS_URL
```

### Logs

```bash
# Kubernetes logs
kubectl logs -f deployment/cqe-api -n cqe

# Docker logs
docker logs -f cqe-api

# Local logs
tail -f logs/cqe.log
```

## Scaling Guidelines

### Vertical Scaling
- **Small**: 512MB RAM, 0.5 CPU (100-200 req/min)
- **Medium**: 2GB RAM, 2 CPU (500-1000 req/min)
- **Large**: 4GB RAM, 4 CPU (2000+ req/min)

### Horizontal Scaling
- Use HPA with CPU/memory targets
- Recommended: 3-10 replicas
- Add replicas for high availability

### Load Testing

```bash
# Apache Bench
ab -n 1000 -c 10 -p embed.json -T application/json http://localhost:8000/embed

# Hey
hey -n 1000 -c 10 -m POST -H "Content-Type: application/json" -d @embed.json http://localhost:8000/embed
```

## Support

For deployment issues:
- GitHub Issues: https://github.com/yourusername/cqe-production/issues
- Email: team@cqe-research.org
