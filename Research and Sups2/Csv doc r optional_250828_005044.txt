Doc R â€” Preâ€‘CSV Runtime Retrospective & Operating Model (What We Ran Before the CSVâ€‘Only Pivot)
Purpose: Describe how the system operated prior to the CSVâ€‘first redesignâ€”its architecture, data flow, persistence model, determinism gaps, governance, and failure modesâ€”and provide a crossâ€‘walk to the CSV runtime. This is a factual retrospective and an operatorâ€™s guide for emulation/migration.
R1. Executive Summary
Before the CSV pivot, the framework already used the 15â€‘module rule set (CHUNKâ†’SHELLâ†’PRIMâ†’â€¦â†’DFMODE). However, state lived primarily in memory and adâ€‘hoc stores (vector indices, transient caches, notebooks), with decisions logged sparsely. Determinism depended on careful operator practice (fixed seeds, pinned models) rather than enforced artifacts. The CSV runtime (Docs Aâ€“N) preserves intent while externalizing all state into appendâ€‘only CSVs with validators, ledgers, and contracts.
R2. Architecture (Preâ€‘CSV)
Layers (in order of execution):
â€¢ Ingest & CHUNK â€” Text split to ~900â€‘char overlapping windows (semantic continuity Â±1 concept).
â€¢ SHELL â€” Prototype modeling assigned each chunk to 1 of 8 shells; missing shells imputed at doc level.
â€¢ PRIM â€” Regex and small parsers extracted atomic primitives; stored as Python objects with provenance fields.
â€¢ BUCKET â€” Perâ€‘doc kâ€‘means (Kâˆˆ[5,16]) yielded buckets; cohesion/separation computed inâ€‘memory.
â€¢ VALID â€” Inward/outward validation; failed moves rolled back to last entropyâ€‘stable state (kept as Python snapshots).
â€¢ GRAPH â€” Relation graph in memory (NetworkX) or a local graph store; edges by Jaccard/Cosine; thresholds in config.
â€¢ ORBIT â€” SVD/UMAP lanes and stability radii; angles mapped to 8 lanes; parity/chirality bins updated.
â€¢ MACROâ€‘SEED â€” Perâ€‘bucket topâ€‘4 primitives; braid chain with greedy overlap; 8â€‘slot palindromic fold Aâ€“Bâ€“Câ€“Dâ€“Dâ€“Câ€“Bâ€“A.
â€¢ SUP â€” Greedy overlap across bucket heads; compression by n=5 folding; IO gate insertion; legality heuristics.
â€¢ GATE â€” Pair checks (SOI/Buffer/SOI parity) implemented as assertions with fallbacks; no artifact emission.
â€¢ B320 â€” 10â€‘octet packet logic tracked in code; grayâ€‘flag recorded in logs only.
â€¢ LOG â€” Console/file logs; occasional JSON dumps; not canonical.
â€¢ HELIX â€” Dualâ€‘helix assembly for parity checks; metrics in memory.
â€¢ EXC â€” Quarantine upon â‰¥3 shell failures; reassignment logged sparsely.
â€¢ DFMODE â€” Bitsâ†’DataFrames existed as conceptual tiles (inâ€‘RAM DataFrames), not persisted.
Key characteristics: mixed persistence (RAM + notebook cells + adâ€‘hoc JSON), implicit ledgers (timestamped logs), and soft governance (operator signâ€‘off rather than signed contracts).
R3. Data Flow (Operatorâ€™s View)
raw docs â†’ chunk windows â†’ assign shells â†’ extract primitives â†’ cluster â†’ validate â†’ build graph â†’ compute lanes/radii â†’ pick centers/bridges â†’ build seeds â†’ assemble braid (SUP) â†’ gate checks â†’ enumerate futures (DFSS) â†’ pick controller/operator â†’ accept/rollback â†’ (optional) push summaries 
Where state lived: graphs, seeds, and legality flags were Python objects; promotion was a function call that mutated inâ€‘memory structures and printed a log line.
R4. Persistence & Storage (Preâ€‘CSV)
â€¢ Vector store (optional): transient FAISS/Annoy indexes for similarity and recall.
â€¢ Notebook/JSON dumps: sporadic snapshots after milestones (graph, seeds, policy).
â€¢ Logs: stdout/stderr; grepâ€‘friendly but nonâ€‘canonical for reconstruction.
â€¢ No canonical ledger/merkle; recomputation relied on reâ€‘running cells with the same environment.
R5. Determinism Gaps & Mitigations
GapSymptomTypical MitigationEmbedding nondeterminismUMAP/TSNE jitter; lane flipsForce PCA or fix random_state; cache embeddingsSeed driftDFSS ranking flickerHardcode seed=1729; freeze weights; export policy snapshotLibrary driftNumPy/BLAS changesPin requirements.txt; containerizeTimeâ€‘ofâ€‘day inputsRecency biasDisable timeâ€‘weighted recall during eval runsChunk boundary shiftsPrimitive set differencesPersist chunk maps; use stable tokenizersLedger absenceAudit difficultyManual runâ€‘logs; operator signatures 
Even with mitigations, auditors could not replay stepâ€‘forâ€‘step without the original runtime and environment.
R6. Governance & Evidence (Preâ€‘CSV)
â€¢ Promotion: based on policy reports + operator judgment; no machineâ€‘verifiable contract.
â€¢ Evidence: quotes captured in notebooks; alignments sometimes fuzzy without span hashes.
â€¢ Budgets: LAEC tracked informally (counters in code); no packet/window mapping enforced.
â€¢ MGL: implied conventions; overlap audits were advisory, not blocking.
R7. Legality & Gates (Operational Reality)
â€¢ CI/Parity/SOI: implemented as Python assertions; failing checks triggered try/repair loops.
â€¢ Buffer Gate: conceptual (entropy proxy computed), but no floor enforcement artifact; overrides werenâ€™t journaled.
â€¢ Octet uniqueness: checked, but duplicate triads sometimes slipped until later consolidation.
R8. Performance & Quality Signals
â€¢ Stability: geometry ğ’œ deltas and cleanâ€‘flag tracked in memory; no CSV trail.
â€¢ Scoring: DFSS/AltDFSS produced ranked dicts; screenshots or JSON blobs used as proof.
â€¢ A/B: occasional spot comparisons; no standardized scoreboards or CI.
R9. Failure Modes (Observed)
â€¢ Octet collision cascades after lane realignment.
â€¢ Parity drift when bridges applied without reâ€‘binning chirality.
â€¢ Braid collapse if seed order violated palindromic fold under edits.
â€¢ Recall loops due to recency bias (promptâ€‘local reinforcement).
â€¢ Irreproducible audits when logs missed intermediate states.
R10. Why the Pivot to CSV
â€¢ Reproducibility: full recompute from files + ops.yml.
â€¢ Auditability: ledgers/merkle; packet audits.
â€¢ Governance: contracts, budgets, watchers.
â€¢ Portability: vendorâ€‘neutral artifacts; simple diffs.
â€¢ Interoperability: adapters to C2PA/Sigstore/OTel/lakehouse.
R11. Emulation Profile (Run "Legacy" inside CSV Runtime)
To faithfully recreate preâ€‘CSV behavior for backtests or parity checks, run with this profile:
ops.yml: scoring_policy: alt detector_policy: spectral buffer_gate: expand_policy: aggressive entropy_floor_eps: 0.0 mgl_overlap_audit: warn laec: windows_per_run: 9999 recall_policy: explore_first strict_even: false 
â€¢ Disable hard floors; allow aggressive expansions; treat MGL overlaps as warnings; relax budgets; prefer Orbit@cursor recall.
â€¢ Evidence: allow fuzzy align (Ï„_jaccard=0.8) but still log links in EVIDENCE_LINKS.csv.
R12. Oldâ†’New Crossâ€‘Walk
Preâ€‘CSV artifact/behaviorCSVâ€‘first replacementInâ€‘RAM graph (NetworkX)relation_graph_nodes.csv, relation_graph_edges.csv + deterministic buildNotebook policy dictpolicy_cards.json (+ POLICY_SUMMARY.csv)Console promotion notePROMOTION_CONTRACTS.csv + PROMOTION_JOURNAL.csvAdâ€‘hoc evidence snippetsEVIDENCE_LINKS.csv with span+hashImplicit ledgerLEDGER_WINDOWS.csv (+ MERKLE_WINDOWS.csv)Handâ€‘tracked LAECenergy_budget.csv with counters and windowsConceptual tilesdf_* CSVs or views (DFMODE materialized)Advisory MGLMGL_REGISTRY.csv + overlap audits (strict/warn) 
R13. Minimal Repro (Legacyâ€‘style)
â€¢ Set emulation profile (R11).
â€¢ Run a packet (Doc N orchestrator).
â€¢ Compare outputs to preâ€‘CSV notebook using policy order and Orbit states.
â€¢ Tighten gates incrementally until parity with modern pipeline.
R14. Migration Checklist
â€¢ [ ] Export any notebook JSON blobs into CSV headers.
â€¢ [ ] Rebuild graphs from intake using fixed thresholds.
â€¢ [ ] Reâ€‘compute lanes/radii with PCA (seeded).
â€¢ [ ] Materialize seeds and palindromic fold; record lineage.
â€¢ [ ] Convert evidence snippets into spanâ€‘anchored links.
â€¢ [ ] Create PromotionContracts for accepted truths.
â€¢ [ ] Run packet audit; store manifest.
â€¢ [ ] Freeze ops.yml; tag run_id.
R15. Takeaways
The preâ€‘CSV system captured most of the logic but not the guarantees. The CSV runtime makes every decision replayable, every override explicit, and every audit mechanical, without losing the original braidâ€‘driven synthesis or legality stack.
End Doc R â€” This is your authoritative map of â€œwhat we used to run,â€ why it was insufficient for audit, and how to emulate it safely within the CSVâ€‘first runtime.