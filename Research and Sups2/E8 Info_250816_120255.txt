Exploring the E8 Lattice: Shell Enumeration, Projections, and SNAP State Design

Constructing and Enumerating E8 Lattice Shells

The E8 lattice can be defined as all 8-dimensional vectors whose coordinates are either all integers or all half-integers, with the additional constraint that the sum of coordinates is an even integer. Equivalently, one may describe E8 as the integral span of 240 root vectors of length √2 (the E8 root system). These 240 shortest nonzero vectors (roots) form the first shell around the origin. Beyond this root shell, the lattice has concentric shells of points at increasing norm (squared distance) from the origin. A remarkable formula gives the number of vectors on the shell of squared norm 2m: 240 · σ₃(m) for m ≥ 1, where σ₃(m) is the sum of cubes of the positive divisors of m. (For example, there are 240 vectors of norm 2, 2160 vectors of norm 4, 6720 of norm 6, etc., growing rapidly with m.) This reflects the highly symmetric and dense nature of E8.

Efficient generation of shell vectors is non-trivial given the combinatorial explosion in counts. A brute-force search for all solutions to  (with E8’s parity conditions) becomes infeasible as m grows. Instead, one exploits E8’s symmetry. The Weyl group of E8 (order 696,729,600) acts transitively on each shell, partitioning the shell into orbits of equivalent points. In particular, the subgroup  (order 128·8! ≈ 20 million) consists of all coordinate permutations and an even number of sign flips. Using these symmetry operations, one can generate a shell by first enumerating only distinct “patterns” of coordinates (e.g. sorted absolute values) and then applying permutations and sign changes to recover all vectors. For example, in the first shell one finds that 112 of the 240 roots have the pattern of two ±1’s and six 0’s (up to permutation) while the other 128 have the pattern of eight ±½’s with an equal number of positives and negatives. By listing one representative per symmetry type and then multiplying by the orbit size, one efficiently obtains the full shell without redundant searching. This was the strategy used in published enumerations of E8 shells – each shell’s vectors can be broken into a few types (distinguished by coordinate pattern and parity) and generated by group actions. In practice, one can also split the problem by the two cosets of E8: one coset is the D₈ sublattice (all coordinates even, sum even) and the other is an offset by half-units (all coordinates odd, sum even). Solutions can be found in each coset separately and then combined. Modern implementations may use a meet-in-the-middle or backtracking approach guided by these symmetry reductions – for instance, fixing a sorted absolute coordinate tuple and iterating possible values that satisfy . The known formula 240·σ₃(m) can serve as a check on completeness. Overall, by leveraging the lattice’s algebraic structure (root basis and Weyl group) one can enumerate shell nodes in increasing order of norm without enumerating an exorbitant search tree. This enables exploration “beyond the root system” to deeper shells in a feasible manner.

Projecting E8 Shells into 2D and 3D

 Visualization of the 240 E8 root vectors (first shell) projected onto a 2D plane (the Coxeter plane). This projection yields a highly symmetric pattern of points and connecting lines (edges of the 4<sub>21</sub> polytope). Only some of E8’s symmetries are visible in this 2D projection.

Visualizing an 8-dimensional lattice in 2 or 3 dimensions requires choosing a suitable projection that preserves as much structure as possible. A common technique is to use the Coxeter plane of the E8 Coxeter–Weyl group. This is a two-dimensional plane associated with the E8 Coxeter element (of order 30) onto which all 240 root vectors can be projected. The resulting 2D plot (see above) shows the root shell as a set of concentric circles of points with intricate symmetry. Adjacent root points in the 8D lattice are connected by edges in this projection, producing a distinctive star-like figure (the Petrie projection of the 8-dimensional 4<sub>21</sub> polytope). The Coxeter-plane projection is ideal for human interpretability because it concentrates as much of E8’s  symmetry as possible into two dimensions – for instance, the 30° rotational symmetry of the diagram corresponds to the Coxeter element’s action. Tools like SageMath can compute this projection by finding an orthonormal basis for the Coxeter plane (often via the eigenvectors of the Coxeter element). Notably, John Stembridge and others have produced such 2D projections of E8’s root system, and the pattern of 240 points has inspired physical models and drawings. Keep in mind that any 2D projection inevitably overlaps some points or hides certain symmetries (the E8 lattice has far more symmetry than can be embedded in the plane), but the Coxeter plane choice maximizes the visible regularity.

For 3D projections, one strategy is to project onto a carefully chosen 3-dimensional subspace that corresponds to a symmetric subgroup or cross-section of E8. For example, E8 contains root subsystems isomorphic to D₈ (which is 8-dimensional orthogonal) and to A₈ (the 8-dimensional simplex lattice), as well as non-crystallographic symmetry like the H₄ polytope when appropriately “folded”. By aligning the projection with one of these substructures, one can obtain a 3D arrangement of points with familiar symmetry. A famous case is the icosahedral projection: it’s known that the 240 E8 roots can be split into two sets of 120 that each correspond (under projection) to the vertices of a 600-cell (the H₄ 4-dimensional polytope with 120 vertices). In practice, this means there is a 4D subspace of R^8 in which the E8 points project to the configuration of two concentric 600-cells; choosing a 3D view along a certain axis (through the center of these 600-cells) yields a beautiful 3D visualization with icosahedral symmetry. (In this view, one axis of the 3D projection corresponds to an H₄ symmetry axis, so the shadow in 3D has the rotational symmetry of an icosahedron/dodecahedron.) Indeed, a Zome model constructed by mathematicians represents the E8 root system as a 3D ball-and-stick model with icosahedral and octahedral symmetry axes. The vertical axis of that model aligns with a 30-point circle (seen as concentric rings in a 2D projection) and reveals a “tunnel” through the object – a consequence of E8’s concentric shell structure. In general, to project E8 shells (not just roots) to 3D, one can use similar approaches: choose an orthonormal basis of three vectors in 8D that accentuates a desired symmetry or subgroup. For instance, projecting onto the subspace spanned by three simple roots of an A₃ or D₄ subsystem would highlight a cubic/octahedral cluster of lattice points; projecting along an E7 axis (treating E8 as E7×A1) might show a 7D layer compressed into a 3D “stack.” There is also the possibility of using stereographic projection from the surface of a high-dimensional sphere, or radial projection that preserves angular relationships of lattice points, but these are more exotic. In summary, for human-friendly pictures one typically uses linear projections aligned with E8’s symmetry planes. The Coxeter plane (2D) and the H₄ folding (which gives a 3D view with polyhedral symmetry) are two successful examples. These projections allow us to see the layered structure of shells and even identify patterns like concentric polyhedral arrangements of lattice points that would be impossible to discern directly in 8D.

SNAP States and Hierarchical Exploration of the Lattice

To interactively explore the E8 lattice, we propose a system of “SNAP” states (snapshot states) that store the necessary data to return to a particular point or configuration in the lattice. Each SNAP state would encapsulate:

A reference lattice point or shell: e.g. the coordinates of a specific lattice node that is the current “origin” or center of focus. By saving the exact vector (in some canonical form, such as the 8-tuple of doubled coordinates to avoid fractions), the system can always relocate this point in the lattice. This allows the user to “bookmark” interesting nodes or regions and revisit them later. For example, one might save the state corresponding to a second-shell point of norm 4, or a point in the offset sub-lattice (coset) of E8, and be able to jump back to it.

Local geometric data: information about the structure of the lattice around that reference point. This can include the list of neighboring lattice points (the first shell relative to that point) or the facets of the Voronoi cell around that point. Storing the local neighbor graph is especially useful because each E8 lattice point has a very high coordination number – for instance, each lattice point has 240 nearest neighbors at distance √2, and is surrounded by 2160 cross-polytope facets (8-orthoplexes) and 17,280 simplex facets in the Voronoi decomposition. Rather than recompute these structures from scratch, a SNAP state could cache the adjacency list or Voronoi facet normals once, when the user first explores that point. This enables faster “interior zoom”: the user can click on a neighboring point and instantly shift focus to it (becoming the new center) because the system already knows the connection. Hierarchical exploration becomes feasible – one can start at the origin, expand to see its neighbors (shell 1), then pick one neighbor and make it the center of a new neighborhood (shells now computed around that new center), and so on. Because the E8 lattice is homogeneous, every local neighborhood is isometric to every other, but a SNAP state captures the orientation and context the user was looking at. This means the system can reveal nested substructures, such as showing that if you focus on a lattice point from the second coset (half-integer coordinates), the immediate arrangement of neighbors might appear as a rotated version of the original due to an automorphism mapping between cosets. Storing the local orientation (see next item) would let the interface highlight these correspondences.

Orientation and projection settings: the viewing perspective or basis used when the user saved the state. This includes any rotation or reflection applied to align the lattice in a convenient way, and any projection to 2D/3D for visualization. By recording the orientation (for example, as an 8×8 orthogonal matrix or a set of basis vectors in the original coordinate system), the SNAP state ensures that when we return to that state, we see the lattice in the same pose as before. This is crucial for reproducibility: the E8 lattice has many symmetries, so a slight change in orientation could make the projection look very different. The orientation can be restricted to symmetry-respecting transformations – for instance, the interface might allow only rotations from the E8 automorphism group (Weyl group actions) to ensure that lattice points always map to lattice points. By storing an orientation as a sequence of symmetry operations (like reflections through known root hyperplanes or coordinate permutations), the system could apply the exact transform every time, avoiding numeric drift. In addition, the SNAP state would include the projection mode (e.g. Coxeter plane 2D projection, or a particular 3D subspace projection) so that the same mode is reinstated. If the user had, say, a view emphasizing an A₄ sub-lattice plane, that choice is saved.

Barycentric or internal coordinates: It can be useful to store the position of the reference point in a basis independent way, such as barycentric coordinates relative to some fundamental region of the lattice. For example, one could express the point in terms of the 8 simple roots of E8 or in terms of a decomposition into two D₈ coset vectors. These barycentric coordinates (which might be fractional) can help in reconstructing the point and also in understanding its internal position within the Voronoi cell. For instance, if a user “zooms in” to examine the interior of a Voronoi cell (the region closer to one lattice point than any other), barycentric coordinates relative to the cell’s vertices could pinpoint a location. Storing such coordinates along with the state means the system could regenerate any interior exploratory point (not just lattice nodes) – for example, the center of the Voronoi cell or a intersection of certain facet planes – which might be relevant for studying packing or symmetry centers. Moreover, these coordinates provide a natural way to enforce constraints: e8’s Voronoi cell is an 8-dimensional polytope (the Gosset 4<sub>21</sub> polytope), and barycentric coordinates can ensure a point stays inside it or on a symmetric subsection if needed.

Symmetry constraints and filters: A SNAP state could also record any symmetry-based filters the user applied. For example, the user might be exploring only those lattice points that lie in a particular sub-lattice or satisfy a condition (like a fixed sum of coordinates mod 4). Or perhaps the user has turned on a constraint to only move between points along certain symmetric directions (analogous to restricting movement along axes in a cubic lattice). By saving these settings, the state ensures that returning to it will restore the same rules of exploration. This helps in hierarchical exploration because one might drill down into a substructure – for instance, focusing only on the D₈ sub-lattice within E8 – and later come back and continue where they left off. The SNAP state can store that we were, say, “viewing E8 as two interpenetrating D₈ lattices” so that any further expansion respects that perspective. Additionally, if the user highlighted certain symmetry planes or nearest-neighbor clusters, those can be recorded (e.g. “mark the 8 neighbors forming an orthoplex cross”). Essentially, the SNAP state acts like a bookmark with memory of not just which point, but how and under what assumptions that point was being viewed.

In designing the data structure for SNAP states, using a human-readable format (like JSON or XML) with named fields for each component is advisable for transparency and versioning. For example:

{
  "name": "Shell3_PointA",
  "base_point": [0, 1, -1, 0, 0, 0, 0, 0], 
  "orientation": [[... 8x8 matrix ...]],
  "projection": "coxeter_plane",
  "neighbor_cache": [ [0,1,-1,0,0,0,0,0], [½,½,½,½, -½,-½,-½,-½], ... ],
  "constraints": {"coset": "D8", "max_shell": 3}
}

Such a snapshot might represent an E8 lattice point on the 3rd shell, with a stored orientation and a cached list of its immediate neighbors (perhaps represented in a compressed or canonical form). By loading this state, the program would set the lattice’s coordinate system to the saved orientation, plot the neighbors (from the cache) around the base point, and enforce that we’re only exploring the D₈ sub-lattice up to shell 3 in this view (as per the constraints). The user could then continue the exploration—e.g. expand to shell 4—at which point the system could update the state’s neighbor cache or prompt to save a new state.

In summary, the SNAP state mechanism provides memory in the exploration process. It supports hierarchical or recursive exploration (“zooming in” on different nodes or regions) by ensuring that when you revisit a state, you see the same local universe you saw before. This is crucial in a complex structure like E8 where it’s easy to get “lost” due to the high symmetry. With named SNAP states, a researcher can navigate the lattice much like navigating a graph or an indexed database of points, confident that each return yields the same local configuration of shells, orientations, and constraints as initially saved.

Computational Tools and Libraries for E8 Lattice Work

Managing the E8 lattice – from exact vector enumeration to high-precision projection calculations – calls for powerful computational tools. Below we recommend several libraries and languages suited to this task, each with its strengths:

SageMath (Python-based): SageMath has built-in support for root systems and lattices, including E8. It can directly construct the E8 root system and provide the simple roots, root lattice, and even visualizations in lower dimensions. For example, one can do RootSystem(["E",8]).ambient_space().plot() in Sage to get a 2D Coxeter plane plot of the E8 roots. Sage is adept at symbolic and exact arithmetic – all E8 coordinates can be kept as rationals or half-integers exactly, and one can work in number fields (e.g. adjoin √5) to exactly represent coordinates of certain projections. This avoids numerical rounding errors when, say, computing the precise Coxeter plane basis or verifying that a projected configuration has the expected symmetry. Sage also interfaces with combinatorial and group theory libraries; the Weyl group of E8 and its orbits can be manipulated using Sage’s algebraic combinat features. Overall, SageMath is ideal for developing prototype algorithms for shell enumeration (using its Python language to implement orbit-stabilizer or backtracking searches) and for ensuring mathematical correctness through symbolic checks. Its high-level commands (like listing all roots or short vectors of a lattice) are very convenient for E8. The trade-off is speed – Sage (being Python-based) can be slower for extremely large computations, but it can leverage fast underlying libraries (GAP, PARI, etc.) for many operations.

Python with NumPy/SymPy: A more lightweight approach is to use Python’s scientific libraries. NumPy can efficiently handle large arrays of integers or floats and could be used to represent batches of lattice vectors and perform vectorized operations (like dot products to filter by norm). For instance, one implementation generated the 240 E8 root vectors using itertools.product and NumPy in just a few lines. NumPy’s strength is numerical computation, so it could handle generating thousands of lattice points per shell and performing geometric transformations on them. If high precision or exact arithmetic is needed, SymPy (for symbolic math) or Python’s fractions.Fraction can be introduced – e.g. SymPy can solve Diophantine equations or work with sqrt symbols exactly, which might help in deriving the Coxeter plane vectors or analyzing the structure of the Voronoi cell symbolically. Python also has specialist libraries: for instance, pycddlib can compute convex hulls and polytope facets; this was used to find all edges of the E8 polytope by treating the 240 roots as vertices. One can combine such tools to get local structural information (like adjacency of lattice points). The Python ecosystem’s advantage is ease of use and flexibility – one can prototype complex logic (like the SNAP state management or a custom shell generator) relatively quickly. The downside is performance: pure Python loops might be too slow for enumerating very large shells. However, by delegating heavy tasks to NumPy (C-optimized) or to compiled libraries, one can mitigate this. Python is an excellent choice for interactive exploration (especially in a Jupyter notebook setting), where one might generate a shell, plot it, tweak parameters, and so on in real-time.

Julia: Julia is a modern language designed for high-performance numerical and scientific computing, which makes it very suitable for a demanding task like E8 lattice enumeration. Julia can approach C-like speeds while retaining a high-level syntax. For lattice computations, one could use Julia to implement efficient algorithms (e.g. a backtracking search for solutions to  with pruning) without the overhead of Python. Julia also has arbitrary precision arithmetic and rational number types built in, so it can handle the half-integers and any algebraic numbers without loss of precision. In terms of libraries, Julia’s ecosystem includes Polymake.jl and CDDLib.jl for polyhedral computations (the latter interfaces with the CDD library for convex hulls and has recently added support for vertex adjacency queries). This could be used, for example, to compute the Voronoi cell of E8 or verify neighbor relationships. Julia is also strong in linear algebra, which is helpful for projection: computing an orthonormal basis for a given subspace (like the Coxeter plane or any 3D slice) is straightforward with Julia’s linear algebra standard library, even at high precision or for large matrices. If needed, Julia can call C/C++ or Python code, which means one can integrate special-purpose code (for example, use a C routine optimized for sum-of-squares enumeration) into a Julia workflow. For visualization, Julia has plotting packages that can display 2D/3D point clouds (e.g. using Makie.jl for interactive 3D graphics). This opens the possibility of an interactive E8 explorer written in Julia, where performance-intensive tasks (like generating the 1000th shell or animating rotations of a large point cloud) run efficiently. Julia is a great choice when scaling up the computation – for instance, if you want to enumerate shells far beyond what’s been published, or handle millions of points, a Julia implementation will likely outperform pure Python by a large margin.

Other Tools: For completeness, we note that Java/C++ could be used for ultimate performance if one is writing a specialized program (e.g. a custom backtracking search for lattice vectors or a graphical application for E8). There are also algebra systems like Magma or PARI/GP that are adept at lattice computations and number theory; Magma in particular has lattice enumeration functions that might handle something like E8 (though its license is closed-source). However, using an interactive language like Python or Julia is generally more convenient for experimentation. Additionally, specialized libraries exist in narrower domains: for example, GAP (Group Algebra Program) can work with the E8 Weyl group and could be scripted to generate orbits, and MATLAB (with symbolic toolbox) could in principle do similar tasks as Python/Sympy for smaller-scale exploration.

In the context of high-precision projections, if one needed to get extremely accurate coordinates (say, to distinguish subtle geometric features or to create a physical model), using a rational or algebraic representation is key. Libraries like Sympy (Python) or Nemo/Hecke (Julia’s number theory libraries) allow one to treat objects like  or  exactly. For example, the basis vectors for the Coxeter plane of E8 involve the eigenvalues , which lead to coordinates in the field  (containing  and other algebraics). A symbolic approach can derive a simplified basis with nice algebraic entries, which can then be turned into numerical coordinates at the final step for plotting. If using pure numerical methods, one can resort to arbitrary precision arithmetic (e.g. Python’s mpmath or Julia’s BigFloat) to ensure that rounding doesn’t break symmetries (for instance, ensuring that points that should coincide in a projection are truly identical within tolerance).

Finally, for visualization and interactive exploration tools, there are some existing resources that one can build upon. The AIM development of Coxeter plane plots (via John Stembridge) is accessible through SageMath. There is also an interactive Wolfram Demonstration (Mathematica) by J. G. Moxness that builds up E8-related structures in 2D/3D – one could adapt similar techniques in an open-source environment. For a fully interactive 3D experience, projects like Wizard Gynoid’s Virtual E8 Polytope have shown it’s possible to visualize E8 in virtual reality with user-controlled rotation and exploration. An open-source implementation could use Unity3D or Three.js with precomputed projection data. For example, one might precompute the first several shells of E8 (using the methods and libraries above), then use a 3D engine to render points and allow the user to fly through the structure, clicking to create SNAP states, etc. The numerical libraries will ensure the data fed into such an engine is accurate and rich (including metadata like edges or facet planes for drawing connective lines or polytope faces).

In summary, a combination of Sage/Python (for algebraic power) and Julia/C (for performance) is recommended. SageMath can serve as a reference implementation (to double-check results symbolically and use its knowledge of E8’s structure), while a language like Julia or optimized Python (NumPy) can handle the heavy lifting of enumerating vectors and computing projections. By carefully using these tools – generating lattice shells with symmetry reductions, projecting via computed basis vectors, and storing state data – one can create a robust computational framework to explore the E8 lattice interactively and reproducibly. Each of these choices ensures that neither the scale of E8 (with its thousands of vectors per shell and 8-dimensional complexity) nor the precision required (rational/irrational coordinates and subtle symmetries) becomes a limiting factor in revealing the beauty of E8.

Sources:

1. Moorhouse, E. “The First Thousand Shells of the E8 Root Lattice.” ericmoorhouse.org/e8/ – Definition of E8 lattice coordinates and shell enumeration formula.

2. Conway, J.H., Sloane, N.J.A. Sphere Packings, Lattices and Groups, 3rd ed. (1999) – Background on E8 as the unique even unimodular lattice in 8D; root system properties.

3. Crans, A. AMS Feature Column (Sep 2022) – “Eight-dimensional spheres and the exceptional E8” – Accessible description of E8 lattice and its 240-root polytope; coordinate basis example.

4. Wikipedia – “E8 lattice” and “E8 (mathematics)” – *Various facts about E8 lattice symmetry and substructures; Voronoi cell facets; root sublattices (D8, A8, etc.)*.

5. Richter, D. (2007). Zome model of the E8 root system – *Photograph and description of a 3D projection of E8 with icosahedral symmetry (two 600-cells)*.

6. SageMath Documentation – “Visualizing root systems” tutorial – *Method for projecting root systems onto the Coxeter plane (including E8)*.

7. R.ブログ (R-Bloggers) – “The E8 root polytope” (Laurent Bartholdi, 2022) – Example code generating E8 roots with NumPy and finding polytope edges with cddlib; discusses projection basis.

8. Moxness, J.G. (2017). “3D Visualization of E8 Using an H4 Folding Matrix.” – Describes techniques to project E8 into 3D by aligning with H4 (icosahedral) subspace; basis derivations. (Archived on academia.edu)

9. Imaginary.org – “Wizard Gynoid’s Virtual E8 Polytope” – Notes on an interactive art installation of E8 in VR, demonstrating various symmetry axes in 3D.