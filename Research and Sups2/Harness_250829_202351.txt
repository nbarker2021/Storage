""" UVIBS-GPT wrapper
A thin harness that lets any proposer (LLM or heuristic) suggest 8-length windows and routes them through the UVIBS core legality engine.
Usage (script): python uvibs_gpt.py --phi 0 --strict 0 --steps 16 --seed 1 --base 10
It will: • Build a UVIBSController with the chosen regime • Generate proposed 8-windows (palindromic-biased) from the prompt/seed • Lift each window into 80D, attempt a legal hop (W4/exp/W80 + governance repair) • Log outcomes to CSV
You can replace propose_windows() with an actual LLM call; just return a list [np.ndarray] of shape (8,) with digits 1..n (n≈base or alphabet size). """ from future import annotations import argparse from pathlib import Path import random import numpy as np import pandas as pd
Import the core that lives alongside this file (canvas-provided)
import uvibs_core_v1 as core
------------------------- Proposer (stub) -------------------------
def propose_windows(prompt: str, *, base: int, n: int, steps: int, seed: int) -> list[np.ndarray]: """Heuristic proposer biased to palindromic/near-pal windows. Replace with an LLM that returns the same structure. Digits are 1..n (consistent with the core's geometry helpers). """ rng = random.Random(seed) out: list[np.ndarray] = [] # Simple bias knobs inferred from prompt prefer_pal = ("pal" in prompt.lower()) or True for t in range(steps * 2): # over-generate; routing may reject some if prefer_pal and (t % 2 == 0): left = [rng.randint(1, n) for _ in range(4)] w = np.array(left + left[::-1], dtype=int) else: # near-pal: copy pal and flip one position with small delta left = [rng.randint(1, n) for _ in range(4)] pal = left + left[::-1] i = rng.randint(0, 7) pal[i] = ((pal[i] - 1 + rng.choice([-1, 1])) % n) + 1 w = np.array(pal, dtype=int) out.append(w) if len(out) >= steps: break return out
------------------------- Lifting & Routing -----------------------
def lift_window_to_80D(v: np.ndarray, w8: np.ndarray) -> np.ndarray: """Tile the 8-window across the 80D spine (E8×10) and add into v. This mirrors the analysis path used in metrics. """ assert len(w8) == 8 w80 = np.tile(w8.astype(int), 10) return v + w80
def route_stream(prompt: str, *, phi: bool, strict: bool, base: int, n: int, steps: int, seed: int, out_csv: Path) -> pd.DataFrame: # Build controller ctrl = core.demo_build_controller(phi_on=phi, strict=strict) # Mirror palette follows base: divisors of (b-1) plus 8 partner # (Controller already has (9,10,8) for b=10; adjust if base!=10) if base != ctrl.cfg.base: palette = [] for d in range(2, base): if (base - 1) % d == 0: palette.append(d) palette = tuple(sorted(set(palette + [8]))) ctrl.cfg.base = base ctrl.cfg.mirror_mods = palette
# Seeded proposals proposals = propose_windows(prompt, base=base, n=n, steps=steps, seed=seed) # State v = np.zeros(ctrl.cfg.D, dtype=int) logs = [] for t, w8 in enumerate(proposals): # Gate prefilter: MIRROR/PAL palette gate_ok = any(core.mirror_ok(w8, base, m) for m in ctrl.cfg.mirror_mods) or core.pal_ok(w8) if not gate_ok: logs.append({"t": t, "status": "GATE_REJECT", "window": ''.join(map(str, w8))}) continue # Lift window v_try = lift_window_to_80D(v, w8) # Attempt route starting from the lifted state y, info = ctrl.route_once(v_try) info["t"] = t info["window"] = ''.join(map(str, w8)) info["base"] = base info["phi_on"] = phi info["strict"] = strict info["ok"] = y is not None logs.append(info) if y is not None: v = y df = pd.DataFrame(logs) out_csv.parent.mkdir(parents=True, exist_ok=True) df.to_csv(out_csv, index=False) return df 
----------------------------- CLI --------------------------------
def main(): ap = argparse.ArgumentParser() ap.add_argument("--prompt", type=str, default="Find palindromic rests and re-enter codec.") ap.add_argument("--phi", type=int, default=0, help="1 to enable φ-lane (11/10)") ap.add_argument("--strict", type=int, default=0, help="1 for per-block W80 strictness") ap.add_argument("--base", type=int, default=10) ap.add_argument("--n", type=int, default=10, help="digit alphabet 1..n (geometry)") ap.add_argument("--steps", type=int, default=16) ap.add_argument("--seed", type=int, default=1) ap.add_argument("--out", type=str, default="uvibs_gpt_run.csv") args = ap.parse_args()
df = route_stream( args.prompt, phi=bool(args.phi), strict=bool(args.strict), base=args.base, n=args.n, steps=args.steps, seed=args.seed, out_csv=Path(args.out), ) print(f"Wrote {args.out} with {len(df)} rows.") 
if name == "main": main()