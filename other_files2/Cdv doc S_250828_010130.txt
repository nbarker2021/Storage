Doc S â€” Technical Support Addendum (Baseâ€‘320, Bits, Braid/Helix, Inward/Outward Chains)
Purpose: A deep, formal addendum to Doc R that defines the relationships, numerical choices, and baseâ€‘level mechanics behind the systemâ€”Baseâ€‘320 packet logic, bit usage, the 2â†’4â†’8 geometry chain, inward compression vs outward expansion, and the exact meaning of each n used across the runtime. This document is implementationâ€‘grade and reconciles preâ€‘CSV behavior with the CSVâ€‘first guarantees.
S1. Relationship Map (Conceptual â†’ Operational)
â€¢ Conceptual braid (shells, lanes, chirality, parity) â†’ Operational legality (CI, Parity, SOI, Octet uniqueness).
â€¢ Graph/geometry (centers, bridges, Bandâ€‘8) â†’ Stability & promotion (DFSS/AltDFSS â†’ PromotionScore â†’ Contracts).
â€¢ Energetics (LAEC) â†’ Scheduling (BWâ€‘32 windows â†’ Baseâ€‘320 packets) â†’ Budget governance (windows_per_run).
â€¢ Glyph algebra (triads, MGL) â†’ Deterministic IDs & ledgers (glyph_id, atom_id, ledger_hash, Merkle).
The CSV runtime externalizes each link: graph/geometry CSVs feed legality and policy; legality/energy produce contracts; ledgers/Merkle seal the publish unit (packet).
S2. Why 8, 32, and 320? (Numerical Design Rationale)
Eight (8) underpins lanes, shells, and octet grids:
â€¢ 8 lanes: stable partition of angle Î¸âˆˆ[âˆ’Ï€,Ï€) into equal sectors; pairs naturally with L/R chirality.
â€¢ 8 shells: corpusâ€‘wide semantic prototypes K=8 (balanced, minimal yet expressive) that support the 2â†’4â†’8 spectral ladder.
â€¢ 8Ã—8 octet: per (doc,shell) grid with 64 unique glyph triads, aligning with byteâ€‘like reasoning while preserving symbolic headers.
Thirtyâ€‘two (32) is the window bitâ€‘budget (BWâ€‘32):
â€¢ Even/odd acceptance rhythm (odd = explore/try; even = buffer/commit) needs a small, fixed stride. 32 gives 16 odd trials, 16 even commits max, ample for a window while keeping audits small.
â€¢ 32 decomposes cleanly across 2â†’4â†’8 structures and halves repeatedly under rollback/repair.
Three hundred twenty (320) arises as 10 windows Ã— 32 bits:
â€¢ 10 windows form a packet; packets map to the Baseâ€‘320 packet logic (Module 11) where each of the 10 octets is a validated 32â€‘bit unit with lineage.
â€¢ 320 balances audit granularity (Merkle/ledger per window) with throughput. Packet is the atomic publish unit (Doc L).
S3. Baseâ€‘320 Packet Logic (B320)
Definition: A packet P contains 10 octets ; each octet is a validated 32â€‘bit unit derived from a single windowâ€™s accepted steps and their ledgers.
â€¢ Kernel/Complement dualâ€‘octads: and must pass a braid lock: structural equivalence under parity/chirality symmetry and lane coverage. Failure â†’ grayâ€‘flag packet (excluded from lineage).
â€¢ Chirality balance: signed turn counts across octets must net within tolerance Îµâ‚• (Doc E) to avoid drift.
â€¢ Twist score: record helix twist per octet; packet chirality is the signed sum.
Packet integrity fields (per window/octet): first_ledger_hash, last_ledger_hash, row_count, merkle_root?
S4. Bits, Steps, and the Even/Odd Contract
â€¢ Bit = accepted action (row) within a window. The BWâ€‘32 counter is the limit of accepted writes in that window.
â€¢ Odd steps (explore): O1/O4 (halfâ€‘steps, perâ€‘edge triads); allowed to set up bridges, propose glyph repairs; no permanent bridge commit.
â€¢ Even steps (govern/commit): Buffer Gate must pass (compressâ†’constrainâ†’expand) before acceptance; contracts may be minted.
â€¢ Strictâ€‘even mode (Doc D/H): promotion only on even steps; relaxed in legacy emulation (Doc R Â§R11).
Why bits? Bits give constantâ€‘cost audit slices and deterministic throttling of change. A bit is atomic, replayable, and costed (LAEC).
S5. 8Ã—8 Octet Legality (Per Doc, Per Shell)
â€¢ A legal octet requires 64 unique glyph triads (no duplicate glyph_id) across slots.
â€¢ Parity & chirality bins must distribute as configured (e.g., equal or profileâ€‘weighted).
â€¢ Lane adherence: Bandâ€‘8 occupancy â‰¥ Ï„; protects semantics from drift.
â€¢ Exit criterion from TLattice (Doc H): unique64=true, parity_ok, band8_ok, clean_octadic_ok â†’ stabilized=true.
S6. Braid, Dual Helix, and Braid Lock
â€¢ Braid chain: Ordered glyph triads from bucket seeds overlapped greedily, then folded to the palindrome Aâ€“Bâ€“Câ€“Dâ€“Dâ€“Câ€“Bâ€“A (SUP rule).
â€¢ Dual helix: Octet pairs form a kernel/complement with matching shell parity and opposite chirality. Log twist score and parity flips (HELIX logic).
â€¢ Braid lock (packet): all five pairs must satisfy shell/braid parity alignment within tolerance; else grayâ€‘flag.
S7. Inward vs Outward Chains
Inward (compression path) â€” biases toward legality and minimal entropy:
â€¢ Chunk â†’ Shell (coverage to 8) â†’ Primitive extraction â†’ Bucket (cohesionâ‰¥0.18) â†’ Validate (inward/outward) â†’ Graph edges (Ï„) â†’ Geometry (lower ğ’œ) â†’ Octadic (clean) â†’ DFSS score â†’ Buffer compress â†’ Constrain â†’ Accept.
Outward (expansion path) â€” controlled exploration:
â€¢ Same up to DFSS â†’ Buffer expand (legal variants consistent with constraints K) â†’ score again (Î”LAEC penalty) â†’ accept only if floors & gates pass.
Rule: Expansion never bypasses legality gates; entropy floors forbid â€œfree information.â€ Every expansion increments b_exp in LAEC.
S8. nâ€‘Values: Exhaustive Table
SymbolValueMeaningWhere enforcedK8Number of shells (corpus prototypes)CHUNK/SHELL; imputation to 8 (Doc B)lanes8Angular sectors for geometry/lane mappingDoc E (Î¸ bands)octet slots648Ã—8 grid per (doc,shell); unique glyphsDoc H (TLattice exit); Doc D (legality)BW32Bits per window (accepted rows)Doc H (LAECâ†’windows)P10Windows per packet â†’ 320 bitsDoc H/LB_maxsmallMax futures per window (bounded)Doc F (enumeration)n=55SUP folding factor for braid compressionDoc B/G (Superperm Phase)Îµ_Q~0.03Slack for modularity monotoneâ€‘liftDoc E/MÏ„_cf~0.25Cutâ€‘fraction threshold for cleanâ€‘flagDoc EÎ”_maxconfigDegree cap in relation graphDoc G 
Notes: numeric thresholds are runâ€‘configurable; their existence (and logging) is invariant.
S9. Baseâ€‘320 Encodings (Header Tiles â†’ Bits â†’ Octets â†’ Packet)
Header tile (tile = 8â€‘bit row):
[ shell(3b) | bucket(5b) ] # conceptual encode for invariants view 
In practice, we do not serialize as binary; we record full headers in CSV and compute tiles for Buffer entropy and DFMode traces.
Bit acceptance â†’ writes a row with glyph + headers + ledger hash.
Window (octet) â†’ accumulates â‰¤32 accepted bits; its ledger/Merkle define octet integrity.
Packet (320) â†’ 10 octets + braid lock + chirality balance form the publish unit.
S10. Glyph Triad â†’ Header Bijection (Spec)
â€¢ Decode map is specâ€‘versioned and injective on valid triads.
â€¢ Canonicalization: NFC, collapse spaces (outside quotes), 1â€“3 tokens per item; itemâ€‘internal tokens sorted.
â€¢ ID: glyph_id = H(spec|g_a|g_b|g_c); collisions blocked; overlaps audited against MGL (Doc K).
Why triads? Triads balance specificity (3 degrees of freedom) with compactness, and align with braid overlaps and parity audits.
S11. DFMODE Tiling (Bitsâ†’DataFrames)
To make packets traceable back to primitives, we tile into four DataFrames (conceptual or materialized):
â€¢ df_primitives â€” (primitive id, doc/chunk provenance, shell), weight.
â€¢ df_tiles â€” invariant/variant tile rows (8â€‘bit symbols), bit index, shell, weight.
â€¢ df_shells â€” shell relationships per tile (lane, chirality).
â€¢ df_seeds â€” macroâ€‘seed metadata (anchor_doc, timestamp, braid position).
Join keys: (provenance_doc, provenance_chunk, shell, bucket) Â± glyph id; replays compose the packet from tiles.
S12. Energetics: LAEC â†” Windows â†” Packets
Counters per window: s_acc, r_back, b_exp, e_br, d_dup with weights (1, w_r, w_b, w_e, w_d): Windows needed ; Packets used .
Bridge economy: saved_steps â†’ saved_windows=âŒˆsaved_steps/32âŒ‰; recorded in VALID_MULTI_D_BRIDGE_LOG.csv.
S13. Determinism & Invariants Checklist
â€¢ Fixed ops.yml: seeds, thresholds, degree caps, scoring weights.
â€¢ Canonicalization for glyphs and quote spans; NFC normalization.
â€¢ Stable ordering: within window (step_index, atom_id).
â€¢ Rolling ledger hash per row; optional Merkle root per window.
â€¢ Entropy floors: Hc_out + Îµ â‰¥ Hc_in on Buffer.
â€¢ Octet uniqueness and cleanâ€‘flag required before promotion.
S14. Edge Cases & Failure Modes
â€¢ Octet duplicate â†’ TLattice; glyph repair; reâ€‘impute shells.
â€¢ Cleanâ€‘flag false but DFSS high â†’ RAW controller; halfâ€‘steps only; defer promotions.
â€¢ Braid lock fail (kernel/complement mismatch) â†’ grayâ€‘flag packet; audit required.
â€¢ Mirror/null instability â†’ Throughâ€‘Mode: seeds fixed; AltDFSS overlay; promotions paused.
â€¢ Entropy dip â†’ reject or require GOV override with override_reason.
S15. Worked Microâ€‘Example (Symbolic)
â€¢ Triad: (Î”phase | locked_core | bandâ€‘8) â†’ decode shell=5, bucket=42, octet=12, parity=Odd|L.
â€¢ Accept three odd halfâ€‘steps (bits 1,3,5), then an even commit (bit 6) after Buffer pass â†’ 6 bits consumed.
â€¢ Geometry lowers ğ’œ by âˆ’0.12; Octadic clean; DFSS selects O2 fullâ€‘step â†’ promotion candidate.
â€¢ Window closes at 19 bits; packet later satisfies braid lock; published with row_count=â€¦ and merkle_root=â€¦.
S16. Operator Reference (at a glance)
â€¢ Use 8 for lanes/shells/octets.
â€¢ Cap windows at 32 bits; promotions on even steps; enforce Buffer floors.
â€¢ Publish in 320â€‘bit packets; require braid lock and chirality balance.
â€¢ Log everything (contracts, evidence, ledgers).
â€¢ Repair via TLattice; Explore via RAW; Commit via DEEPEN.
End Doc S â€” This addendum formalizes the baseâ€‘level reasoning behind Baseâ€‘320, bits, braid/helix parity, the 2â†’4â†’8 chain, and the exact n meanings, unifying legacy intent with CSVâ€‘first determinism.