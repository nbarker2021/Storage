# CQE Architecture

## Overview

The Cartan-Quadratic Equivalence (CQE) framework provides a universal embedding system based on E8 lattice geometry. Content is projected into a 248-dimensional space (240 E8 roots + 8 Cartan lanes) and optimized using the MORSR protocol.

## System Components

### Core Engine

**E8 Lattice (`cqe/core/lattice.py`)**
- Implements E8 simple root basis construction
- Provides Babai nearest-plane algorithm for projection
- Supports Weyl reflections and chamber detection
- QR factorization for efficient computations

**Overlay (`cqe/core/overlay.py`)**
- 248-slot data structure (240 roots + 8 Cartan lanes)
- Activation mask (present), weights (w), phases (phi)
- Content-addressed hashing for deterministic retrieval
- Serialization and lifecycle management

**Φ Computer (`cqe/core/phi.py`)**
- Objective function with 4 components:
  - Φ_geom: Geometric smoothness (angular acceleration + radial jitter)
  - Φ_parity: ECC syndrome (Cartan lane parity)
  - Φ_sparsity: L1 norm of active weights
  - Φ_kissing: Deviation from E8 kissing number (240)
- Weighted total: Φ_total = αΦ_geom + βΦ_parity + γΦ_sparsity + δΦ_kissing

### ALENA Operators

**Symmetric Operators** (preserve Φ structure):
- **Rθ (Rotation)**: Quantized Coxeter-plane rotation (θ = k·π/12)
- **WeylReflect**: Reflection across simple root hyperplane

**Asymmetric Operators** (controlled Φ change):
- **Midpoint**: Palindromic parity reduction
- **ParityMirror**: Mirror Cartan lanes across center

**Parity Operators**:
- **ECC-Parity**: Error-correcting code parity check

**Expansion Operators**:
- **SingleInsert**: Controlled slot insertion

### MORSR Protocol

**Middle-Out Ripple Shape Reader**:
1. Initialize with seed overlay
2. For each pulse iteration:
   - Try each operator in sequence
   - Compute Φ after transformation
   - Accept if ΔΦ ≤ 0 (monotone criterion)
   - Log handshake record
3. Converge when no operators accepted

**Handshake Records**:
- Track operator application
- Record Φ before/after
- Acceptance decision and reason
- Overlay hash for provenance

### Domain Adapters

Convert domain-specific content to 8-dimensional feature vectors:

**Text Adapter**:
1. Length (normalized)
2. Character diversity
3. Whitespace ratio
4. Vowel ratio
5. ASCII value distribution
6. Sentence count
7. Long word ratio
8. Hash entropy

### API Layer

**REST API (`cqe/api/rest.py`)**:
- POST `/embed`: Embed content
- POST `/query`: Similarity search
- POST `/transform`: Apply operators
- GET `/metrics/{id}`: Retrieve Φ metrics
- GET `/health`: Health check

**Client API (`cqe/api/client.py`)**:
- High-level Python interface
- Overlay caching
- Operator application
- Similarity queries

### Storage Layer

**Overlay Cache**:
- LRU in-memory cache
- Optional Redis backend
- Content-addressed retrieval
- Statistics tracking

## Data Flow

```
Input → Adapter → Features (8D) → Babai Embedding → E8 Overlay
                                                         ↓
                                                    Canonicalization
                                                         ↓
                                                    MORSR Protocol
                                                         ↓
                                                   Optimized Overlay → Cache
```

## Key Invariants

1. **248-slot structure**: Always 240 roots + 8 Cartan lanes
2. **Cartan power-of-2**: Active Cartan lanes should be power-of-2 (1, 2, 4, 8)
3. **Phase range**: All phases in [-π, π]
4. **Monotone acceptance**: MORSR only accepts ΔΦ ≤ 0
5. **Content addressing**: Overlays identified by deterministic hash

## Performance Characteristics

- **Embedding**: O(n) for n-length content
- **MORSR optimization**: O(k·m) for k iterations, m operators
- **Similarity query**: O(c) for c cached overlays
- **Throughput**: 280+ items/second (validated)

## Deployment Modes

1. **Standalone**: Single-instance Python application
2. **Dockerized**: Containerized with Redis
3. **Kubernetes**: Scalable multi-pod deployment with HPA

## Extension Points

- Custom operators (inherit from `CQEOperator`)
- New domain adapters (inherit from `DomainAdapter`)
- Alternative Φ weights (configure `PhiComputer`)
- Storage backends (implement cache interface)
