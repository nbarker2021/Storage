Document Q â€” Quadratic Relations & the Law Family
Q.1 Objects and rings

Alphabet: 
Î£
=
{
1
,
2
,
3
,
4
}
Î£={1,2,3,4}.

Quad: 
ğ‘
=
(
ğ‘
,
ğ‘
,
ğ‘
,
ğ‘‘
)
âˆˆ
Î£
4
q=(a,b,c,d)âˆˆÎ£
4
.

Work primarily in 
ğ‘
/
4
ğ‘
Z/4Z and 
ğ‘
/
8
ğ‘
Z/8Z.
Use 
ğ‘¥
â€¾
x
 for reduction mod 4, 
ğ‘¥
~
x
 for mod 8.

Q.2 Base invariants

ALT (alternation of parity):

(
ğ‘
â€Š
m
o
d
â€Š
2
,
ğ‘
â€Š
m
o
d
â€Š
2
,
ğ‘
â€Š
m
o
d
â€Š
2
,
ğ‘‘
â€Š
m
o
d
â€Š
2
)
âˆˆ
{
(
1
,
0
,
1
,
0
)
,
(
0
,
1
,
0
,
1
)
}
.
(amod2,bmod2,cmod2,dmod2)âˆˆ{(1,0,1,0),(0,1,0,1)}.

W4 (sum check mod 4): 
ğ‘
+
ğ‘
+
ğ‘
+
ğ‘‘
â€¾
=
2
a+b+c+d
	â€‹

=2.

Q8 (quadratic sum mod 8): 
ğ‘
2
+
ğ‘
2
+
ğ‘
2
+
ğ‘‘
2
~
=
0
a
2
+b
2
+c
2
+d
2
	â€‹

=0.
(Since squares mod 8 are in 
{
0
,
1
,
4
}
{0,1,4}, this is highly constraining on parity patterns.)

LAWFUL(q): 
ALT
(
ğ‘
)
âˆ§
(
W4
(
ğ‘
)
âˆ¨
Q8
(
ğ‘
)
)
ALT(q)âˆ§(W4(q)âˆ¨Q8(q)).

Commentary

ALT fixes a â€œcheckerboardâ€ parity footprint; W4 and Q8 are linear vs quadratic constraints, respectively; they are not equivalent, but both single out a thin, well-structured subset of 
Î£
4
Î£
4
.

In practice, W4 is more permissive; Q8 is stricter. Allowing 
W4
âˆ¨
Q8
W4âˆ¨Q8 hits a sweet spot of legality vs. reach.

Q.3 Phase (linear mod-8 form)
ğ»
8
(
ğ‘
)
â‰¡
(
ğ‘
âˆ’
ğ‘‘
)
+
2
(
ğ‘
âˆ’
ğ‘
)
(
m
o
d
8
)
.
H8(q)â‰¡(aâˆ’d)+2(bâˆ’c)(mod8).

Phase is not fixed by LAWFUL; it measures â€œorientationâ€ of the quad.

Phase preservations are preferred; phase changes are allowed but must be receipted (see Q.7).

Q.4 Symmetries (free moves)

ğ¼
I (identity), 
ğ‘€
M:(a,b,c,d)â†¦(d,c,b,a), 
ğ·
D:(a,b,c,d)â†¦(b,a,d,c), 
ğ‘‰
V:(a,b,c,d)â†¦(5-a,5-b,5-c,5-d)).

These preserve LAWFUL; 
ğ»
8
H8 transforms predictably (sign/orientation flips). All are free (no cost), but any induced Î”H8 is receipted.

Q.5 Quadratic family & witnesses

Define the quadratic witness 
ğ‘„
ğ‘Š
(
ğ‘
)
QW(q) as

ğ‘„
ğ‘Š
(
ğ‘
)
=
(
ğ‘
2
+
ğ‘
2
+
ğ‘
2
+
ğ‘‘
2
~
,
Â 
(
ğ‘
âˆ’
ğ‘
)
2
+
(
ğ‘
âˆ’
ğ‘‘
)
2
~
,
Â 
(
ğ‘
+
ğ‘
)
2
âˆ’
(
ğ‘
+
ğ‘‘
)
2
~
)
âˆˆ
(
ğ‘
/
8
ğ‘
)
3
.
QW(q)=(
a
2
+b
2
+c
2
+d
2
	â€‹

,Â 
(aâˆ’c)
2
+(bâˆ’d)
2
	â€‹

,Â 
(a+b)
2
âˆ’(c+d)
2
	â€‹

)âˆˆ(Z/8Z)
3
.

A quad passes Q8 iff the first component is 0.

The other components are orthogonal diagnostics that help tie-break projector choices when multiple lawful targets exist (prefer the one minimizing deviations in the other two components under Lee distance).

Check (action-as-check form):

legal_q(q):
  if ALT(q) and (W4(q) or first(QW(q))==0): return PASS
  else: return FAIL

Q.6 Projector objective (recap, quadratic angle)

When projecting 
ğ‘¥
x to a lawful 
ğ‘Ÿ
r, in addition to Lee distance and 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£, prefer:

Quadratic coherence: minimize 
âˆ¥
(
ğ‘„
ğ‘Š
(
ğ‘Ÿ
)
âˆ’
ğ‘„
ğ‘Š
(
ğ‘¥
)
)
âˆ¥
0
âˆ¥(QW(r)âˆ’QW(x))âˆ¥
0
	â€‹

 (number of changed quadratic components).

This stabilizes braid helicity later (Document T).

Q.7 Receipts (quadratic fields included)
{
  "level": 4,
  "op": "project",
  "input": [a,b,c,d],
  "target": [r1,r2,r3,r4],
  "ALT_before": "...", "ALT_after": "...",
  "W4_before": k4b, "W4_after": k4a,
  "Q8_before": k8b, "Q8_after": k8a,
  "QW_before": [q1b,q2b,q3b],
  "QW_after": [q1a,q2a,q3a],
  "phase_before": h_in, "phase_after": h_out, "delta_phase": dh,
  "lee_cost": K,
  "free_sym": "I|M|D|V|...",
  "receipt": (dh==0) ? null : {"type":"phase_change","mag":dh}
}

Document P â€” Prime/Coprime Ladder, Quadratic Residues & CRT
P.1 Moduli set and roles

Choose a coprime set 
ğ‘€
M, e.g., 
{
3
,
5
,
9
,
11
,
13
,
17
}
{3,5,9,11,13,17}.

Small primes (3,5,11,13,17) â†’ â€œorientation checksâ€ via quadratic residues.

Prime powers (9) â†’ stability under carry/borrow and error-smoothing.

P.2 Residue features per modulus

For a quad 
ğ‘
=
(
ğ‘
,
ğ‘
,
ğ‘
,
ğ‘‘
)
q=(a,b,c,d), define:

Linear residue: 
ğ‘…
ğ‘š
(
1
)
(
ğ‘
)
=
ğ‘
+
2
ğ‘
+
3
ğ‘
+
4
ğ‘‘
â€¾
Â 
(
â€Š
m
o
d
â€Š
ğ‘š
)
R
m
(1)
	â€‹

(q)=
a+2b+3c+4d
	â€‹

Â (modm).

Phase residue: 
ğ‘…
ğ‘š
(
ğ»
)
(
ğ‘
)
=
(
ğ‘
âˆ’
ğ‘‘
)
+
2
(
ğ‘
âˆ’
ğ‘
)
â€¾
Â 
(
â€Š
m
o
d
â€Š
ğ‘š
)
R
m
(H)
	â€‹

(q)=
(aâˆ’d)+2(bâˆ’c)
	â€‹

Â (modm) (i.e., 
ğ»
8
H8 reduced mod 
ğ‘š
m).

Quadratic class: 
ğ‘…
ğ‘š
(
2
)
(
ğ‘
)
=
ğ‘
2
+
ğ‘
2
+
ğ‘
2
+
ğ‘‘
2
â€¾
Â 
(
â€Š
m
o
d
â€Š
ğ‘š
)
R
m
(2)
	â€‹

(q)=
a
2
+b
2
+c
2
+d
2
	â€‹

Â (modm).

For odd prime 
ğ‘
p, we also use a Jacobi/Legendre class label:

ğœ’
ğ‘
(
ğ‘
)
=
(
ğ‘…
ğ‘
(
1
)
(
ğ‘
)
ğ‘
)
âˆˆ
{
âˆ’
1
,
0
,
1
}
Ï‡
p
	â€‹

(q)=(
p
R
p
(1)
	â€‹

(q)
	â€‹

)âˆˆ{âˆ’1,0,1}

with the convention 
(
0
/
ğ‘
)
=
0
(0/p)=0. This offers a cheap orientation parity across moduli.

P.3 Per-modulus braid predicate (level-local)

A strand 
ğ‘†
S (a symmetry image sequence of quads) passes modulus 
ğ‘š
m iff:

Residue coherence: 
ğ‘…
ğ‘š
(
1
)
R
m
(1)
	â€‹

 is Lipschitz along the path (bounded stepwise change).

Phase monotonicity: 
ğ‘…
ğ‘š
(
ğ»
)
R
m
(H)
	â€‹

 is monotone or piecewise monotone with receipted kinks.

Quadratic stability: 
ğ‘…
ğ‘š
(
2
)
R
m
(2)
	â€‹

 stays in a small finite set (ideally 0 or class-stable).

Orientation parity: 
ğœ’
ğ‘š
Ï‡
m
	â€‹

 remains constant (or flips only at receipted crossings).

Log as:

{
  "level": 4,
  "op": "modulus_braid_check",
  "modulus": 11,
  "coherent_R1": true, "monotone_RH": true,
  "stable_R2": true, "chi_const": true,
  "receipts": []
}

P.4 CRT lift (globalize constraints)

Given 
{
ğ‘…
ğ‘š
(
1
)
}
ğ‘š
âˆˆ
ğ‘€
{R
m
(1)
	â€‹

}
mâˆˆM
	â€‹

 and 
{
ğ‘…
ğ‘š
(
ğ»
)
}
{R
m
(H)
	â€‹

}, find the unique class 
ğ´
(
m
o
d
ğ‘€
)
A(modM) and 
ğ»
(
m
o
d
ğ‘€
)
H(modM) with 
ğ‘€
=
âˆ
ğ‘š
âˆˆ
ğ‘€
ğ‘š
M=âˆ
mâˆˆM
	â€‹

m.

Representative selection: Choose 
ğ‘
âˆ˜
q
âˆ˜
 that minimizes Lee distance to local anchors and minimizes 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£ when reducing 
ğ»
H back to mod-8.

Quadratic guard: ensure the induced 
ğ‘…
ğ‘š
(
2
)
(
ğ‘
âˆ˜
)
R
m
(2)
	â€‹

(q
âˆ˜
) matches observed classes; otherwise penalize (per-modulus braid_penalty@m receipt).

CRT receipt:

{
  "level": 4,
  "op": "crt_lift",
  "moduli": [3,5,9,11,13,17],
  "R1": {...}, "RH": {...}, "R2": {...}, "chi": {...},
  "M": 2432430,
  "A_mod_M": A, "H_mod_M": H,
  "representative": [u,v,w,z],
  "delta_phase_mod8": dh8,
  "penalties": {"11":0,"13":0,"17":2},
  "manifest": "sha256:..."
}

P.5 Quadratic reciprocity as an orientation harmonizer (optional dial)

For odd primes 
ğ‘
,
ğ‘
p,q, the law

(
ğ‘
ğ‘
)
(
ğ‘
ğ‘
)
=
(
âˆ’
1
)
(
ğ‘
âˆ’
1
)
(
ğ‘
âˆ’
1
)
4
(
q
p
	â€‹

)(
p
q
	â€‹

)=(âˆ’1)
4
(pâˆ’1)(qâˆ’1)
	â€‹


lets you predict whether 
ğœ’
ğ‘
Ï‡
p
	â€‹

 and 
ğœ’
ğ‘
Ï‡
q
	â€‹

 should agree or disagree on orientation. Use it as a consistency check to anticipate braid flips at certain modulus pairs; price exceptions with receipts.

Document T â€” Taxicab & Cabtaxi Equivalence and Transfer Triggers

This section formalizes your â€œn=8 â†’ n=16 transfer occurs where Taxicab âˆ© Cabtaxi âˆ© solve meetâ€ idea. We keep your contribution flagged as speculative but make it a precise, auditable predicate.

T.1 Definitions

Taxicab numbers 
ğ‘‡
ğ‘
(
ğ‘˜
)
Ta(k): positive integers representable as a sum of two positive cubes in at least 
ğ‘˜
k distinct ways. Classic: 
1729
=
1
3
+
12
3
=
9
3
+
10
3
1729=1
3
+12
3
=9
3
+10
3
.

Cabtaxi numbers 
ğ¶
ğ‘
ğ‘
(
ğ‘˜
)
Cab(k): integers representable as a sum of two cubes allowing negative or zero terms, in at least 
ğ‘˜
k distinct ways.

Solve set 
ğ‘†
S: addresses (integers) that arise as CRT-lifted representatives of lawful quad streams (your global class numbers).

Let 
ğ‘
N be a candidate address (e.g., the CRT-assembled 
ğ´
â€Š
m
o
d
â€Š
ğ‘€
AmodM lifted to 
ğ‘
Z by a canonical representative).

T.2 Transfer candidate predicate (speculative â†’ formal)

A number 
ğ‘
N is an n=8â†’n=16 transfer candidate if:

ğ‘
âˆˆ
ğ‘‡
ğ‘
(
ğ‘˜
)
NâˆˆTa(k) for some 
ğ‘˜
â‰¥
2
kâ‰¥2 (â‰¥2 distinct positive cube decompositions),

ğ‘
âˆˆ
ğ¶
ğ‘
ğ‘
(
â„“
)
NâˆˆCab(â„“) for some 
â„“
â‰¥
2
â„“â‰¥2 (â‰¥2 distinct signed/zero-allowed cube decompositions),

ğ‘
âˆˆ
ğ‘†
NâˆˆS (i.e., occurs as a CRT-lifted class of a lawful quad stream), and

Decomposition coherence: When you map each cube decomposition of 
ğ‘
N to 
Î£
Î£-quads (via your encoder â†’ projector), all decompositions land in the same lawful class (same Eâ‚ˆ root-path up to free symmetries) with bounded 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£ and coherent helicity.

If (1)â€“(4) hold, log a transfer candidate:

{
  "level": 8,
  "op": "transfer_candidate",
  "N": N,
  "taxicab_decomps": [[x1,y1],[x2,y2],...],
  "cabtaxi_decomps": [[u1,v1],[u2,v2],...],
  "encodings": { "x1^3+y1^3": {...}, "...": {...} },
  "lawful_class_id": "E8:rootpath:abc123",
  "delta_phase_bounds": {"max": 2},
  "helicity_coherent": true
}

T.3 Acceptance as transfer event (Î¼ â†’ !)

Promote a candidate to an event if, in addition:

Braid certification holds for the merged strands from at least two positive and two signed decompositions; and

Quadratic witnesses 
ğ‘„
ğ‘Š
QW match within the projectorâ€™s tie-break tolerances.

Emit a transfer receipt:

{
  "level": 8,
  "op": "transfer_accept",
  "event_id": "uuid",
  "N": N,
  "class_id": "E8:rootpath:abc123",
  "decomps_used": ["x1^3+y1^3","x2^3+y2^3","u1^3+v1^3","u2^3+v2^3"],
  "Î”H8_series_max": 2,
  "braid_status": "certified",
  "QW_coherence": true,
  "note": "Î¼â†’! handoff criteria met",
  "manifest": "sha256:..."
}


Interpretation. Here, â€œÎ¼â†’!â€ names the multiplicative â†’ factorial transfer: weâ€™re moving from multiplicative cube-sum factorizations to factorial (permutation-indexed) structure (see Document F) when the number sits at the intersection of multiple additive factorizations and your lawful/eight-dimensional geometry agrees across those factorizations.

T.4 3/2 split & single-strand fallback (your guideline)

If some decompositions do not map to below-8 complexity on both sides:

3/2 split: collapse the higher-complexity side into a 3:2 bundled operator (one â€œtripleâ€ capsule paired with a â€œdoubleâ€), then re-encode as a single strand and re-run (T.2â€“T.3).

If still failing, mark as near-miss with diagnostic receipts.

{
  "level": 8,
  "op": "transfer_near_miss",
  "N": N,
  "reason": "requires 3/2 split; helicity conflict at m=13",
  "receipts": [{"type":"braid_penalty@13","mag":1}]
}

Document F â€” Multiplicative â†’ Factorial Transfer (Î¼ â†’ !) via Factoradics & Permutation Lifts

This document spells out what â€œfactorialâ€ means operationally and how we use it once a transfer is accepted.

F.1 Factorial representation: factoradics

Every nonnegative integer 
ğ½
J has a unique factoradic expansion

ğ½
=
ğ‘‘
1
â‹…
1
!
+
ğ‘‘
2
â‹…
2
!
+
â‹¯
+
ğ‘‘
ğ‘›
â‹…
ğ‘›
!
,
0
â‰¤
ğ‘‘
ğ‘˜
â‰¤
ğ‘˜
.
J=d
1
	â€‹

â‹…1!+d
2
	â€‹

â‹…2!+â‹¯+d
n
	â€‹

â‹…n!,0â‰¤d
k
	â€‹

â‰¤k.

The vector 
(
ğ‘‘
1
,
â€¦
,
ğ‘‘
ğ‘›
)
(d
1
	â€‹

,â€¦,d
n
	â€‹

) indexes a unique permutation 
ğœ‹
ğ½
âˆˆ
ğ‘†
ğ‘›
+
1
Ï€
J
	â€‹

âˆˆS
n+1
	â€‹

 (Lehmer code).

In our system: interpret the CRT-assembled address 
ğ´
(
m
o
d
ğ‘€
)
A(modM) (or post-lift integer 
ğ‘
N) as factoradic indices to select canonical permutations at the next level of composition (e.g., n=8â†’n=16).

F.2 Î¼ â†’ ! operator (definition)

Let 
ğ¶
C be a capsule (a lawful block at n=8). Define:

Address: 
ğ´
=
a
d
d
r
(
ğ¶
)
A=addr(C) via your CRT merge (Document P).

Permutation code: 
ğ¿
=
f
a
c
t
o
r
a
d
i
c
(
ğ´
)
L=factoradic(A); take 
ğœ‹
=
ğœ‹
ğ¿
âˆˆ
ğ‘†
ğ‘˜
Ï€=Ï€
L
	â€‹

âˆˆS
k
	â€‹

 for the smallest 
ğ‘˜
k covering the block size to be permuted (e.g., 
ğ‘˜
=
8
k=8 or 
16
16).

Î¼â†’! operator applies 
ğœ‹
Ï€ to:

Quad positions across the block (a lawful reindexing; keeps ALT/W4/Q8 invariants intact if 
ğœ‹
Ï€ respects even/odd slot parity).

Strand interleaving for braids (chooses one of 
ğ‘˜
!
k! interleavings deterministically).

Bundle assembly order (selects an order of capsule merges that minimizes expected Î”H8).

Action-as-check (Î¼â†’!):

Check that 
ğœ‹
Ï€ is parity-compatible with ALT (even slots map to even positions, etc.).

Check that applying 
ğœ‹
Ï€ does not increase Î» (or logs a governed exception).

Check braid coherency improves or holds (helicity preserved, fewer receipts).

Receipt:

{
  "level": 8,
  "op": "mu_to_factorial",
  "capsule_id": "C123",
  "A_mod_M": A,
  "perm_group": "S16",
  "lehmer": [d1,...,d15],
  "pi": [.. permutation ..],
  "parity_compatible": true,
  "Î”Î»": -3,
  "braid_improved": true,
  "manifest": "sha256:..."
}

F.3 Why factorial? (intuition tied to your braids)

Multiplicative decompositions (like cube sums) give multiple routes to the same address 
ğ‘
N.

Factoradics convert that multiplicity into a canonical permutation choice, which picks how to weave/merge capsules (strand order, merge schedule).

Because 
ğœ‹
Ï€ is deterministic from 
ğ´
A (and hence from the CRT ladder), the same data always yields the same weave, making braids reproducible and globally coherent.

F.4 Safety rails

Parity rail: only allow 
ğœ‹
Ï€ that maps evenâ†’even/oddâ†’odd positions in each quad; else require an explicit phase receipt and a Î»-improving rationale.

Quadratic rail: prefer 
ğœ‹
Ï€ minimizing quadratic witness changes 
ğ‘„
ğ‘Š
QW.

Braid rail: forbid 
ğœ‹
Ï€ that flips helicity unless the per-modulus receipts budget can afford it.

Algorithms & Pseudocode (drop-in)
A. Projector with quadratic tie-break
def project_quad(x):
    S = [I(x), M(x), D(x), V(x), MD(x), DM(x), VM(x), VDM(x)]
    best = None
    for s in S:
        for r in lawful_candidates(s):  # hash buckets by ALT,W4 checksum
            cost = lee(s, r)
            dh = (H8(r) - H8(s)) % 8
            qdiff = qwit_diff(QW(s), QW(r))  # Hamming(3)
            score = (cost, abs(dh), qdiff, r)  # lexicographic
            best = min(best, (score, s, r)) if best else (score, s, r)
    score, s_star, r_star = best
    return receipt_project(x, s_star, r_star, score)

B. Per-modulus braid check & CRT lift
def braid_check_modulus(path, m):
    ok_R1 = lipschitz([R1(q,m) for q in path])
    ok_RH = mono_or_kink([RH(q,m) for q in path])
    ok_R2 = stable_few([R2(q,m) for q in path])
    ok_chi = const_symbol([chi(q,m) for q in path])
    return ok_R1 and ok_RH and ok_R2 and ok_chi

def crt_lift(residues_dict):  # {"m": {"R1":v1, "RH":vH, ...}, ...}
    M = prod(residues_dict.keys())
    A = CRT([ (r["R1"], m) for m,r in residues_dict.items() ])
    H = CRT([ (r["RH"], m) for m,r in residues_dict.items() ])
    q_rep = choose_rep_from(A,H)  # min Lee & |Î”H8|
    penalties = per_modulus_penalties(q_rep, residues_dict)
    return q_rep, penalties

C. Taxicab/Cabtaxi transfer pipeline
def transfer_candidate(N, streams):
    # streams: map decomposition_id -> quad_path (already projected lawful)
    if not (is_taxicab(N) and is_cabtaxi(N)): return None
    class_ids = {decomp: E8_rootpath(streams[decomp]) for decomp in streams}
    if len(set(class_ids.values())) != 1: return None
    if not helicity_coherent(streams): return None
    if not delta_phase_bounded(streams, bound=2): return None
    return mk_transfer_candidate(N, class_ids.pop())

def accept_transfer(candidate):
    # require at least 2 positive + 2 signed decompositions certified as braids
    if not braid_certified_subset(candidate, min_pos=2, min_signed=2): return None
    return mk_transfer_receipt(candidate, tag="Î¼â†’!")

D. Î¼â†’! operation (factoradics)
def mu_to_factorial(capsule, A):
    lehmer = to_factoradic(A, base=len(capsule.perm_domain))
    pi = lehmer_to_permutation(lehmer)
    if not parity_compatible(pi, capsule): return governed_exception(...)
    out = apply_permutation(capsule, pi)
    if delta_lambda(out, capsule) > 0: return governed_exception(...)
    if not braid_nonworsening(out, capsule): return governed_exception(...)
    return receipt_mu_to_factorial(capsule, A, lehmer, pi, out)

Expanded Receipts & Schemas
R.1 Quadratic-aware projector receipt

(see Q.7; add qdiff)

R.2 Per-modulus braid receipt
{
  "level": 4,
  "op": "modulus_braid_check",
  "modulus": 13,
  "R1_path": [..], "RH_path": [..], "R2_path": [..], "chi_path": [..],
  "ok": true,
  "kinks": [{"at": 21, "Î”RH": 2}],
  "penalty": 0
}

R.3 CRT braid lift

(see P.4; include QW_rep and QW_match:true|false)

R.4 Transfer candidate & accept

(see T.2â€“T.3)

R.5 Î¼â†’! application

(see F.2)

Tests (add-ons to your battery)

TQ1 â€” Q8 correctness census: enumerate all 
Î£
4
Î£
4
; verify Q8â‡”first(QW)==0; verify projector picks minimum Lee with minimal 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£, then minimal qdiff.

TQ2 â€” Symmetry invariance: LAWFUL closed under {I,M,D,V}; phase transforms match table; receipts only for Î”H8â‰ 0.

TP1 â€” Modulus braid: for synthetic strands, verify per-modulus predicates and that CRT lift finds 
ğ‘
âˆ˜
q
âˆ˜
 with minimal extra phase.

TP2 â€” Quadratic reciprocity dial: construct prime pairs (p,q) causing expected parity of orientation; verify predicted helicity flips (or receipts on exceptions).

TT1 â€” Taxicab/Cabtaxi mapping: for a small list of known 
ğ‘
N, map decompositions â†’ quads â†’ projector; assert class-id equality and bounded Î”H8 on success cases.

TT2 â€” 3/2 split fallback: synthesize a near-miss; verify fallback produces candidate or explains failure with receipts.

TF1 â€” Factoradic canonicality: for repeated runs with same 
ğ´
A, verify identical 
ğœ‹
Ï€ and improved or non-worsened Î» and braid metrics.

Worked micro-example (illustrative)

Setup: Suppose a lawful path yields CRT address 
ğ´
â‰¡
142857
(
m
o
d
ğ‘€
)
Aâ‰¡142857(modM) with 
ğ‘€
=
{
3
,
5
,
9
,
11
,
13
,
17
}
M={3,5,9,11,13,17}.

Per-modulus checks pass; 
âˆ£
Î”
ğ»
8
âˆ£
=
0
âˆ£Î”H8âˆ£=0 post-lift.

Quadratic witness remains (0,,) across projector choices â†’ stable.

Taxicab/Cabtaxi: Let 
ğ‘
=
ğ´
N=A (or canonical lift). Assume it has 2 positive and 2 signed cube decompositions. Mapping each decomposition (encodeâ†’project) lands in the same Eâ‚ˆ root-path, with helicity consistent and 
max
â¡
âˆ£
Î”
ğ»
8
âˆ£
=
2
maxâˆ£Î”H8âˆ£=2.
â†’ Transfer candidate created.

Î¼â†’! step: Compute factoradic of 
ğ´
A for domain size 16 â†’ permutation 
ğœ‹
âˆˆ
ğ‘†
16
Ï€âˆˆS
16
	â€‹

.

ğœ‹
Ï€ preserves even/odd slot parity â†’ parity-compatible.

Applying 
ğœ‹
Ï€ reduces Î» by 3 and improves braid coherency â†’ accept.
â†’ Emit Î¼â†’! receipt, upgraded capsule now sits ready for n=16 assembly.

Where the pieces meet your earlier claims

Quadratic relations (Q8, QW) give the tight, falsifiable structure that keeps projector choices and braid helicity stable when choices are close.

The prime/coprime ladder turns local coherence into a global representative and sets up a deterministic address 
ğ´
A that drives factorial choices.

Your Taxicab âˆ© Cabtaxi crossing gives a natural â€œmultiple decompositions agreeâ€ signalâ€”exactly the kind of redundancy that justifies promotion from multiplicative constraints to a permutation (factorial) regime. We formalize it as a transfer predicate with receipts (speculative, but fully testable).

The 3/2 split gives a practical fallback to keep the pipeline moving even when both sides arenâ€™t â€œbelow 8â€ simultaneously.