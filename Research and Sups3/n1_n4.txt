Document 1 â€” n=1: Primitives

(â€œatoms,â€ encodings, invariants, free symmetries, unit operators, costs, receipts)

1.1 Purpose & scope

Level n=1 defines the primitive alphabet, primitive objects, and primitive actions. Everything above this level is a finite composition of n=1 pieces plus checks. The job of n=1 is to (a) encode arbitrary input into the same finite alphabet, (b) preserve enough structure to recover meaning, and (c) expose â€œfreeâ€ transformations that donâ€™t spend any budget.

1.2 Alphabet, objects, and chunking

Digit alphabet: 
Î£
=
{
1
,
2
,
3
,
4
}
Î£={1,2,3,4} (base-4).

Atomic symbol: 
ğ‘ 
âˆˆ
Î£
sâˆˆÎ£.

Atomic tuple (length 
ğ‘˜
k): 
ğ‘
=
(
ğ‘
1
,
â€¦
,
ğ‘
ğ‘˜
)
a=(a
1
	â€‹

,â€¦,a
k
	â€‹

), 
ğ‘
ğ‘–
âˆˆ
Î£
a
i
	â€‹

âˆˆÎ£.

Chunkers: functions that map raw bytes, tokens, coordinates, etc. into sequences over 
Î£
Î£. Choose the one that preserves your domainâ€™s obvious guards (e.g., endianness, sign, categorical bins).

Byte â†’ Î£ (balanced): map nybbles 
{
0
,
â€¦
,
15
}
{0,â€¦,15} to pairs in 
Î£
Ã—
Î£
Î£Ã—Î£ via a balanced lookup to minimize bias.

Text â†’ Î£: map UTF-8 codepoints to Î£ using a prefix-free code (Kraft-McMillan satisfied) whose weights are near-uniform in Î£.

Reals â†’ Î£: quantize to dyadic bins per feature, then compress to Î£ via order-preserving bin maps.

Design note: Encoders are replaceable as long as they are reversible and produce 
Î£
Î£-sequences. The checks later give domain-agnostic meaning.

1.3 Free symmetries (cost-free checks)

On any finite sequence over 
Î£
Î£, the following free maps preserve legality once n=4 is reached and are always allowed at n=1:

Identity 
ğ¼
I

Mirror 
ğ‘€
M: reverse order inside each window (definition depends on window size; for n=1 use per-block reversal later lifted at n=4).

Dual 
ğ·
D: swap middle coordinates in a 4-tuple (becomes concrete at n=4; at n=1 we allow the promise of D inside future quads).

Inverse 
ğ‘‰
V: digitwise involution 
ğ‘¥
â†¦
5
âˆ’
ğ‘¥
xâ†¦5âˆ’x (i.e., 
1
â†”
4
1â†”4, 
2
â†”
3
2â†”3).

These are â€œfreeâ€ because they merely permute representations. They incur no ledger cost and no receipt unless they change phase (defined later; phase receipts begin at n=4).

1.4 Unit operators (paid)

Atomic increment/decrement 
ğ‘’
ğ‘–
Â±
e
i
Â±
	â€‹

: on a sequence, add/subtract 1 mod 4 at position 
ğ‘–
i.

Cost: 
c
o
s
t
(
ğ‘’
ğ‘–
Â±
)
=
1
cost(e
i
Â±
	â€‹

)=1.

Compositionality: Costs add; later weâ€™ll show subadditivity when you legalize in bundles (nâ‰¥4).

1.5 Distances & energies

Lee distance on digits: 
ğ›¿
ğ¿
(
ğ‘¥
,
ğ‘¦
)
=
min
â¡
(
âˆ£
ğ‘¥
âˆ’
ğ‘¦
âˆ£
,
4
âˆ’
âˆ£
ğ‘¥
âˆ’
ğ‘¦
âˆ£
)
Î´
L
	â€‹

(x,y)=min(âˆ£xâˆ’yâˆ£,4âˆ’âˆ£xâˆ’yâˆ£).

Lee distance on tuples: 
ğ‘‘
ğ¿
(
ğ‘
,
ğ‘
)
=
âˆ‘
ğ‘–
ğ›¿
ğ¿
(
ğ‘
ğ‘–
,
ğ‘
ğ‘–
)
d
L
	â€‹

(a,b)=âˆ‘
i
	â€‹

Î´
L
	â€‹

(a
i
	â€‹

,b
i
	â€‹

).

Î»-energy (pre-legalization heuristic): a convex proxy that counts obvious violations (e.g., alternating parity defect once youâ€™re at n=4) and distance to a local center. At n=1 you only measure Î»; it becomes active at n=4.

1.6 Receipts & ledger (n=1 fields)

Even at n=1, every paid operator emits a ledger line:

{
  "level": 1,
  "op": "e_i+",
  "index": i,
  "before": x,
  "after": (x+1)%4,
  "cost": 1,
  "free": false,
  "timestamp": "...",
  "run_id": "...",
  "note": "pre-legalization n=1 adjustment"
}


No phase yet (phase is defined on quads at n=4). Free symmetries at n=1 are recorded as free:true.

1.7 Guarantees at n=1

Uniform lexicon: arbitrary inputs are now Î£-sequences.

Auditability: every paid change is logged.

Reversibility boundary: encoding/decoding is reversible; legality is not enforced at n=1 (thatâ€™s n=4â€™s job).

Document 2 â€” n=2: Mapping Any Space

(pairs, local guards, the â€œtwo-primitive mapping theorem,â€ edge extension via mirror & parity, and CRT residues as local coordinates)

2.1 Why n=2 matters

n=2 is where structure appears cheaply: pairs allow you to encode adjacency, orientation, and local guards without paying heavy costs. Crucially, n=2 is where you can prove the Two-Primitive Mapping Theorem: two single primitives are sufficient to map the entire datum space associated with a single connection and its extensions.

2.2 Objects at n=2

Pair: 
ğ‘
=
(
ğ‘
,
ğ‘
)
âˆˆ
Î£
2
p=(a,b)âˆˆÎ£
2
.

Guard function 
ğº
2
G
2
	â€‹

: a boolean predicate on pairs that captures a domainâ€™s trivially checkable regularity (examples below).

Examples of 
ğº
2
G
2
	â€‹

:

Parity guard: parity(a) â‰  parity(b) (alternation precursor).

Monotone guard: 
ğ‘
â‰¤
ğ‘
aâ‰¤b for ordered features.

Type guard: classes assigned to a and b must belong to an allowed relation table (categorical data).

2.3 The Two-Primitive Mapping Theorem (informal â†’ constructive)

Claim. Given any two observed, distinct primitives 
ğ‘¢
,
ğ‘£
âˆˆ
Î£
u,vâˆˆÎ£ that occur with a forced relation under mirroring/parity (i.e., at least one guard in 
ğº
2
G
2
	â€‹

 holds for a pair that includes both), you can map the entire local datum space of the connection they sit onâ€”and by edge extension (mirror + parity), you can expand that map outward to cover any connected component of the dataset. Once any segment of that component reaches n=4 (quads), the remainder is solvable upwards at scale.

Intuition. With two distinct symbols 
ğ‘¢
â‰ 
ğ‘£
u
î€ 
=v, pairs 
(
ğ‘¢
,
ğ‘£
)
,
(
ğ‘£
,
ğ‘¢
)
(u,v),(v,u) provide a basis of directionality. Mirroring gives you the reverse edges for free, and a parity/monotone guard prevents pathological collapse. From those seeds:

you label edges (pairs) along the connection,

attach local residues mod small primes (3,5,â€¦) to record where along the connection each pair sits,

and accumulate enough local constraints that any missing interior can be filled using free symmetries first, and one-step paid moves if needed.

Constructive algorithm (edge extension)

Seed: Start with any observed pair 
ğ‘
0
=
(
ğ‘¢
,
ğ‘£
)
p
0
	â€‹

=(u,v) that satisfies a guard 
ğº
2
G
2
	â€‹

.

Mirror expansion: Add 
ğ‘€
(
ğ‘
0
)
=
(
ğ‘£
,
ğ‘¢
)
M(p
0
	â€‹

)=(v,u) for free to seed the reverse edge.

Neighborhood sweep: For any symbol 
ğ‘¤
w observed adjacent to 
ğ‘¢
u or 
ğ‘£
v, test candidate pairs 
(
ğ‘¢
,
ğ‘¤
)
(u,w), 
(
ğ‘¤
,
ğ‘¢
)
(w,u), 
(
ğ‘£
,
ğ‘¤
)
(v,w), 
(
ğ‘¤
,
ğ‘£
)
(w,v) against 
ğº
2
G
2
	â€‹

. Add all that pass.

Residue tagging: For each accepted pair, compute simple local residues 
ğ‘Ÿ
ğ‘š
â‰¡
ğ‘“
(
ğ‘
,
ğ‘
)
(
m
o
d
ğ‘š
)
r
m
	â€‹

â‰¡f(a,b)(modm) for 
ğ‘š
âˆˆ
{
3
,
5
}
mâˆˆ{3,5} (e.g., 
ğ‘“
(
ğ‘
,
ğ‘
)
=
ğ‘
+
2
ğ‘
f(a,b)=a+2b). Store 
{
ğ‘Ÿ
3
,
ğ‘Ÿ
5
}
{r
3
	â€‹

,r
5
	â€‹

} as local coordinates.

Closure: Repeat steps 2â€“4 until no new pairs are added. The local graph is now mapped.

Edge-to-quad promotion: Slide a window of size 4 across mapped sequences; once enough overlapping pairs exist, you can promote to quads at n=4 (Document 4), where legality is enforced.

Why two primitives suffice. They break symmetry and give you a directed seed; mirrors give inverse edges for free; residues prevent drift and let you align disjoint subpaths when they meet.

2.4 CRT as a local coordinate system

At n=2, we can already start a CRT ladder lightly:

For each pair 
ğ‘
=
(
ğ‘
,
ğ‘
)
p=(a,b), define a local address 
ğ´
(
ğ‘
)
=
ğ›¼
ğ‘
+
ğ›½
ğ‘
A(p)=Î±a+Î²b with coprime 
ğ›¼
,
ğ›½
Î±,Î².

Record 
ğ´
(
ğ‘
)
â€Š
m
o
d
â€Š
3
A(p)mod3 and 
â€Š
m
o
d
â€Š
5
mod5. These two residues are enough to disambiguate collisions in small neighborhoods. When you promote to n=4 you will merge these across windows.

Ledger example (n=2 mapping step):

{
  "level": 2,
  "op": "pair_accept",
  "pair": [u,v],
  "guard": "parity",
  "free": true,
  "residues": {"mod3": r3, "mod5": r5},
  "note": "edge extension via mirror+parity"
}

2.5 Failure modes & recovery

Guard conflict: If 
(
ğ‘¢
,
ğ‘¤
)
(u,w) passes parity but 
(
ğ‘¤
,
ğ‘¢
)
(w,u) fails monotone, keep both but annotate the conflict; it is resolved at n=4 by the projector.

Sparse data: If only one of 
(
ğ‘¢
,
ğ‘£
)
(u,v) or 
(
ğ‘£
,
ğ‘¢
)
(v,u) is seen, synthesize the mirror edge (free). If synthesis later contradicts Î»-energy at n=4, youâ€™ll pay there with a receipt.

Document 3 â€” n=3: Triads, Entropy & Braid Initiation

(triples as the ubiquitous geometric motif; â€œshortcut landerâ€ vs â€œbraid starterâ€; first level where entropy must be budgeted; per-modulus braid predicates)

3.1 Why n=3 is unique

Geometry loves three. Triangles (three points) determine orientation, curvature hints, and minimal cycles.

Action density. Most nontrivial choices happen when extending from pairs to triples.

Entropy enters. This is the first level where competing, near-equivalent options proliferate, and you must budget entropy explicitly.

3.2 Objects & guards at n=3

Triple: 
ğ‘¡
=
(
ğ‘
,
ğ‘
,
ğ‘
)
âˆˆ
Î£
3
t=(a,b,c)âˆˆÎ£
3
.

Flow (chirality) guard 
ğº
3
â†»
G
3
â†»
	â€‹

: e.g., a signed local phase slope (defined via future H8 over a sliding window) or a simple monotone trend (up-then-down vs down-then-up).

Triangle inequality proxy: cost(t) â‰¤ cost(a,b)+cost(b,c) (subadditivity precursor).

3.3 Roles: Shortcut lander vs Braid starter

Shortcut lander. When two possible quads compete, a well-chosen triple decides the route cheaply. You select the triple that minimizes expected legalization cost at n=4 (look-ahead over Lee distance + phase penalties).

Braid starter. Many sequences admit two interleaved symmetry images of equal pre-cost. If you keep both with consistent helicity sign (defined below), you create a two-strand proto-braid that will be certified at n=4 and above.

3.4 Entropy accounting at n=3

Introduce an entropy budget 
ğµ
ğ‘†
B
S
	â€‹

 and a selection entropy 
ğ»
sel
H
sel
	â€‹

 for each triple choice:

From candidate set 
ğ¶
ğ‘¡
C
t
	â€‹

 of triples, define softmax weights 
ğ‘¤
ğ‘–
âˆ
ğ‘’
âˆ’
ğ›½
â€‰
c
o
s
t
^
(
ğ‘¡
ğ‘–
)
w
i
	â€‹

âˆe
âˆ’Î²
cost
(t
i
	â€‹

)
.

ğ»
sel
=
âˆ’
âˆ‘
ğ‘–
ğ‘¤
ğ‘–
log
â¡
ğ‘¤
ğ‘–
H
sel
	â€‹

=âˆ’âˆ‘
i
	â€‹

w
i
	â€‹

logw
i
	â€‹

.

Policy: either (a) pick the mode and burn entropy 
ğ¸
=
ğ»
sel
E=H
sel
	â€‹

 against budget 
ğµ
ğ‘†
B
S
	â€‹

, or (b) keep top-2 (proto-braid) and defer the decision to n=4; in both cases, log a receipt.

Receipt example:

{
  "level": 3,
  "op": "triad_select",
  "candidates": [[a,b,c1],[a,b,c2],[a,b,c3]],
  "beta": 2.0,
  "weights": [0.62,0.27,0.11],
  "decision": "keep_top2",
  "entropy_spent": 0.94,
  "budget_after": 7.06,
  "note": "braid_starter"
}

3.5 Helicity & proto-braids at n=3

Define a local phase slope over a length-4 sliding window proxy:

For consecutive triples sharing a length-2 overlap, project them (virtually) to quads by duplicating the middle symbol and compute a temporary phase 
ğ»
8
âˆ—
H8
âˆ—
 (see Document 4 for real H8).

Helicity increment: 
Î”
ğ»
=
sgn
â¡
(
ğ»
8
ğ‘–
+
1
âˆ—
âˆ’
ğ»
8
ğ‘–
âˆ—
)
â‹…
ğ‘‘
ğ¿
(
ğ‘¡
ğ‘–
,
ğ‘¡
ğ‘–
+
1
)
Î”H=sgn(H8
i+1
âˆ—
	â€‹

âˆ’H8
i
âˆ—
	â€‹

)â‹…d
L
	â€‹

(t
i
	â€‹

,t
i+1
	â€‹

).

Proto-braid predicate @ modulus 
ğ‘š
m: residues of the two top strands 
(
ğ‘Ÿ
ğ‘š
(
1
)
,
ğ‘Ÿ
ğ‘š
(
2
)
)
(r
m
(1)
	â€‹

,r
m
(2)
	â€‹

) alternate consistently and do not violate pair/triple guards.

If the proto-braid predicate holds at several small moduli (e.g., 
ğ‘š
âˆˆ
{
3
,
5
,
9
}
mâˆˆ{3,5,9}), retain both strands for legalization at n=4.

3.6 Subadditivity witness (triad form)

Record whenever a triple can be legalized with cost â‰¤ the sum of its overlapping pairs:

{
  "level": 3,
  "op": "subadditivity_witness",
  "triple": [a,b,c],
  "pair_costs": k1+k2,
  "triple_cost": k3,
  "holds": k3 <= k1+k2
}


Subadditivity at n=3 predicts efficient bundle fixes at n=4.

Document 4 â€” n=4: Quads, Lawfulness & The Projector (The Key)

(formal legality, phase, projector algorithm, receipts, CRT merges, braid certification, and the gateway upward to n=8)

This is the hinge of the entire system. Everything before n=4 prepares candidates; everything after n=4 certifies and scales them. At n=4 you turn â€œdoing thingsâ€ into checking crisp invariantsâ€”with receipts whenever you must â€œspendâ€ phase or cost.

4.1 Objects, invariants, and phase

Quad: 
ğ‘
=
(
ğ‘
,
ğ‘
,
ğ‘
,
ğ‘‘
)
âˆˆ
Î£
4
q=(a,b,c,d)âˆˆÎ£
4
.

Invariants (law family):

ALT: parity alternates,

(
ğ‘
â€Š
m
o
d
â€Š
2
)
â‰ 
(
ğ‘
â€Š
m
o
d
â€Š
2
)
â‰ 
(
ğ‘
â€Š
m
o
d
â€Š
2
)
â‰ 
(
ğ‘‘
â€Š
m
o
d
â€Š
2
)
(inÂ alternation)
.
(amod2)
î€ 
=(bmod2)
î€ 
=(cmod2)
î€ 
=(dmod2)(inÂ alternation).

W4: 
(
ğ‘
+
ğ‘
+
ğ‘
+
ğ‘‘
)
â‰¡
2
Â 
(
â€Š
m
o
d
â€Š
Â 
4
)
(a+b+c+d)â‰¡2Â (modÂ 4).

Q8: 
ğ‘
2
+
ğ‘
2
+
ğ‘
2
+
ğ‘‘
2
â‰¡
0
Â 
(
â€Š
m
o
d
â€Š
Â 
8
)
a
2
+b
2
+c
2
+d
2
â‰¡0Â (modÂ 8).

LAWFUL(q): 
ALT
(
ğ‘
)
Â 
âˆ§
Â 
(
W4
(
ğ‘
)
Â 
âˆ¨
Â Q8
(
ğ‘
)
)
ALT(q)Â âˆ§Â (W4(q)Â âˆ¨Â Q8(q)).

Phase (octad):

ğ»
8
(
ğ‘
)
â‰¡
(
ğ‘
âˆ’
ğ‘‘
)
+
2
(
ğ‘
âˆ’
ğ‘
)
(
m
o
d
8
)
.
H8(q)â‰¡(aâˆ’d)+2(bâˆ’c)(mod8).

Phase is not fixed by lawfulness; changes in phase are allowed but must be receipted.

4.2 Symmetry group (free) on quads

Identity 
ğ¼
I

Mirror 
ğ‘€
:
(
ğ‘
,
ğ‘
,
ğ‘
,
ğ‘‘
)
â†¦
(
ğ‘‘
,
ğ‘
,
ğ‘
,
ğ‘
)
M:(a,b,c,d)â†¦(d,c,b,a)

Dual 
ğ·
:
(
ğ‘
,
ğ‘
,
ğ‘
,
ğ‘‘
)
â†¦
(
ğ‘
,
ğ‘
,
ğ‘‘
,
ğ‘
)
D:(a,b,c,d)â†¦(b,a,d,c)

Inverse 
ğ‘‰
:
(
ğ‘
,
ğ‘
,
ğ‘
,
ğ‘‘
)
â†¦
(
5
âˆ’
ğ‘
,
5
âˆ’
ğ‘
,
5
âˆ’
ğ‘
,
5
âˆ’
ğ‘‘
)
V:(a,b,c,d)â†¦(5âˆ’a,5âˆ’b,5âˆ’c,5âˆ’d)
These preserve the legal set and are free moves (no cost), except they may flip phase sign; any phase change is recorded.

4.3 Distance & objective

Primary metric: Lee distance 
ğ‘‘
ğ¿
(
ğ‘
,
ğ‘Ÿ
)
d
L
	â€‹

(q,r).

Tie-breakers: phase preservation 
âˆ£
Î”
ğ»
8
âˆ£
=
0
âˆ£Î”H8âˆ£=0 preferred; if not possible, minimize 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£ and record receipt; lastly prefer lowest entropy spend and fewest paid atomics.

4.4 The CLTMP projector (Canonical Lawful Transform with Minimal Phase)

Given any input quad candidate 
ğ‘¥
âˆˆ
Î£
4
xâˆˆÎ£
4
, the projector emits a canonical lawful representative 
ğ‘Ÿ
â‹†
r
â‹†
 and a complete receipt/ledger of the path taken.

Algorithm (deterministic):

Generate symmetry images: 
ğ‘†
=
{
ğ¼
,
ğ‘€
,
ğ·
,
ğ‘€
ğ·
,
ğ·
ğ‘€
,
ğ‘‰
ğ·
,
ğ‘‰
ğ‘€
,
ğ‘‰
ğ·
ğ‘€
}
â‹…
ğ‘¥
S={I,M,D,MD,DM,VD,VM,VDM}â‹…x.

For each 
ğ‘ 
âˆˆ
ğ‘†
sâˆˆS: find 
ğ‘Ÿ
âˆˆ
ğ¿
râˆˆL (the lawful set) minimizing 
ğ‘‘
ğ¿
(
ğ‘ 
,
ğ‘Ÿ
)
d
L
	â€‹

(s,r).

If multiple 
ğ‘Ÿ
r tie, choose the one minimizing 
âˆ£
Î”
ğ»
8
âˆ£
=
âˆ£
ğ»
8
(
ğ‘Ÿ
)
âˆ’
ğ»
8
(
ğ‘ 
)
âˆ£
âˆ£Î”H8âˆ£=âˆ£H8(r)âˆ’H8(s)âˆ£ (mod 8).

If still tied, choose the lexicographically smallest 
ğ‘Ÿ
r.

Pick 
ğ‘ 
â‹†
s
â‹†
 with lowest paid distance to its 
ğ‘Ÿ
r. If ties remain, prefer those with 
âˆ£
Î”
ğ»
8
âˆ£
=
0
âˆ£Î”H8âˆ£=0.

Emit 
(
ğ‘Ÿ
â‹†
,
ğ‘ 
â‹†
)
(r
â‹†
,s
â‹†
), the free symmetry used 
ğ‘”
g, the paid atomic plan to reach 
ğ‘Ÿ
â‹†
r
â‹†
 from 
ğ‘¥
x, and a phase receipt if 
Î”
ğ»
8
â‰ 
0
Î”H8
î€ 
=0.

Complexity. The lawful set 
ğ¿
L can be pre-indexed by parity class and checksum; in practice the scan collapses to a few table lookups.

Receipt example:

{
  "level": 4,
  "op": "project",
  "input": [a,b,c,d],
  "symmetry_used": "MD",
  "candidate_after_symmetry": [a',b',c',d'],
  "target_lawful": [r1,r2,r3,r4],
  "lee_cost": 2,
  "phase_before": H8_in,
  "phase_after": H8_out,
  "delta_phase": (H8_out - H8_in) % 8,
  "receipt": (delta_phase==0) ? null : {
    "type":"phase_change",
    "magnitude": k,
    "rationale":"no phase-preserving lawful rep existed"
  },
  "manifest": "sha256:...",
  "free": false
}

4.5 â€œAction as checkâ€ (master equality family)

At n=4, every action is rewritten as a check against the invariants + projector decision rule. Examples:

Legalize: Check if 
âˆƒ
ğ‘Ÿ
âˆˆ
ğ¿
âˆƒrâˆˆL with 
ğ‘‘
ğ¿
(
ğ‘¥
,
ğ‘Ÿ
)
â‰¤
ğ¾
d
L
	â€‹

(x,r)â‰¤K and 
âˆ£
Î”
ğ»
8
âˆ£
=
0
âˆ£Î”H8âˆ£=0. If yes, accept 
ğ‘Ÿ
r; else accept with receipt.

Align two streams: Check if there exist symmetry choices 
ğ‘”
1
,
ğ‘”
2
g
1
	â€‹

,g
2
	â€‹

 such that 
ğ‘‘
ğ¿
(
ğ‘”
1
ğ‘¥
,
ğ‘”
2
ğ‘¦
)
d
L
	â€‹

(g
1
	â€‹

x,g
2
	â€‹

y) is minimized with bounded phase deltas.

This design makes the system provable, reproducible, and auditable.

4.6 CRT merges at n=4 (coprime joins)

With quads legalized, you merge constraints across moduli:

For each quad 
ğ‘
q, compute residues 
ğ‘…
ğ‘š
(
ğ‘
)
R
m
	â€‹

(q) under a selection of coprime moduli 
ğ‘š
âˆˆ
ğ‘€
mâˆˆM (e.g., 
3
,
5
,
9
,
11
,
13
,
17
3,5,9,11,13,17).

For a set of constraints 
{
ğ‘…
ğ‘š
}
ğ‘š
âˆˆ
ğ‘€
{R
m
	â€‹

}
mâˆˆM
	â€‹

, use the Chinese Remainder Theorem to recover a unique class 
ğ‘„
(
m
o
d
ğ‘€
)
Q(modM) where 
ğ‘€
=
âˆ
ğ‘š
M=âˆm.

Select representative 
ğ‘
âˆ˜
q
âˆ˜
 from that class that minimizes 
ğ‘‘
ğ¿
(
ğ‘
âˆ˜
,
ğ‘Ÿ
â‹†
)
d
L
	â€‹

(q
âˆ˜
,r
â‹†
) and 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£ relative to local lawful anchors.

Record penalties if the CRT lift compelled phase spending (per-modulus receipts with braid_penalty@m).

Ledger (CRT-lift):

{
  "level": 4,
  "op": "crt_lift",
  "moduli": [3,5,9,11,13,17],
  "residues": {...},
  "M": 2432430,
  "representative": [u,v,w,z],
  "lee_to_local": 1,
  "delta_phase": 0,
  "penalties": {},
  "manifest": "sha256:..."
}

4.7 Braid certification at n=4

The proto-braids from n=3 are either certified (become stable bonds) or collapsed.

Two-strand normal form: given two symmetry images (strands) of a legalized path, check:

Helicity constancy: signed phase slope keeps its sign,

Strand coherence: consistent residues per modulus,

No law violations: each strand remains lawful (ALTâˆ§(W4âˆ¨Q8)).

Dual-helix witness:

{
  "level": 4,
  "op": "braid_certify",
  "strands": { "A": {...}, "B": {...} },
  "helicity_sign": "+",
  "residue_check": { "3": true, "5": true, "9": true, "11": true, "13": true, "17": true },
  "delta_phase_series": [0,0,0,...],
  "status": "certified"
}


Result: â€œAny valid n=4â†’n=8 bond equal to it displays a dual-helix traitâ€ becomes directly observable as a per-step check/receipt series.

4.8 Governance: dials, budgets, acceptance

Budgets: atomic flips, phase changes, entropy spend, CRT penalties.

QF gate (quality/fitness): accept a projector outcome iff 
Î”
ğœ†
â‰¥
0
Î”Î»â‰¥0 (Î» drops or equal) or attach a governed exception receipt.

Crooks-style policy: occasionally accept a higher-energy option with a priced receipt to escape local traps (annealing-like, but audited).

4.9 Subadditivity (formal witness at n=4)

For any adjoining quads 
ğ‘
1
,
ğ‘
2
q
1
	â€‹

,q
2
	â€‹

 merged into a capsule 
ğ¶
C,

c
o
s
t
(
ğ¶
)
â‰¤
c
o
s
t
(
ğ‘
1
)
+
c
o
s
t
(
ğ‘
2
)
.
cost(C)â‰¤cost(q
1
	â€‹

)+cost(q
2
	â€‹

).

Log violations (they should be rare; if frequent, adjust dials or chunking).

4.10 Outputs and manifests

Every projector call, CRT lift, and braid certification writes:

Structured artifact (JSON/CSV),

Human report (MD/HTML),

Binary byproducts (plots, if applicable),

Manifest entry with SHA-256, run-id, timestamps.

Cross-level quickstart (n=1â†’4 in one pass)

n=1 Encode to Î£; record only paid atomics.

n=2 Edge-extend using mirrors & parity/monotone guards; tag residues mod 3 & 5.

n=3 Choose triples using entropy budgeting; retain up to two strands if proto-braid predicates hold.

n=4 Project each sliding quad via CLTMP; prefer phase-preserving solutions; emit receipts if not possible.

n=4 Merge with CRT across 
{
3
,
5
,
9
,
11
,
13
,
17
}
{3,5,9,11,13,17}; record any penalties; choose representative that minimizes Lee distance and phase change.

n=4 Certify braid (if two strands survived); otherwise collapse to the canonical strand.

n=4 Gate by Î»; log governed exceptions.

Worked example (toy, but complete)

Input: bytes 0x5A 0xE3
n=1: encode nybbles â†’ Î£ pairs (balanced map), suppose â†’ sequence

[
2
,
4
,
1
,
3
,
4
,
1
,
2
,
3
]
[2,4,1,3,4,1,2,3]

n=2: pairs slide: (2,4),(4,1),(1,3),(3,4),(4,1),(1,2),(2,3).
Parity guard passes all. Assign residues 
ğ‘Ÿ
3
=
ğ‘
+
2
ğ‘
(
m
o
d
3
)
r
3
	â€‹

=a+2b(mod3), 
ğ‘Ÿ
5
=
ğ‘
+
2
ğ‘
(
m
o
d
5
)
r
5
	â€‹

=a+2b(mod5).

n=3: triples: (2,4,1),(4,1,3),(1,3,4),â€¦
Softmax choose top-2 for (4,1,3) vs (4,1,2) (close cost) â†’ keep both (proto-braid), log entropy receipt.

n=4: quads slide:

For 
ğ‘¥
=
(
2
,
4
,
1
,
3
)
x=(2,4,1,3), ALT holds (even, even? check) â†’ suppose ALT fails; run CLTMP: try symmetries â†’ 
ğ·
(
ğ‘¥
)
=
(
4
,
2
,
3
,
1
)
D(x)=(4,2,3,1) is 1 flip from a lawful 
ğ‘Ÿ
=
(
4
,
2
,
2
,
4
)
r=(4,2,2,4) with 
Î”
ğ»
8
=
0
Î”H8=0 â†’ accept; cost=1.

For the next quad, a tie forces 
Î”
ğ»
8
=
+
2
Î”H8=+2 â†’ accept with phase receipt.
CRT: merge residues across moduli; representatives chosen with no extra phase spends.
Braid: both strands legalized, helicity consistent â†’ certify dual-helix.
Gate: Î» decreased overall â†’ accepted.
Manifest: write artifacts & hashes.

Appendices (shared across docs)
A. Operator & receipt schema (complete)
{
  "run_id": "uuid",
  "timestamp": "iso-8601",
  "items": [
    {
      "level": 1|2|3|4,
      "op": "encode|e_i+|e_i-|pair_accept|triad_select|project|crt_lift|braid_certify|gate",
      "input": "...",
      "output": "...",
      "free": true|false,
      "cost": 0|1|2|...,
      "lambda_before": "...",
      "lambda_after": "...",
      "phase_before": 0..7|null,
      "phase_after": 0..7|null,
      "delta_phase": 0..7|null,
      "entropy_spent": 0.0,
      "budgets": {
        "atomic": {"used": k, "limit": K},
        "phase": {"used": h, "limit": H},
        "entropy": {"used": e, "limit": E}
      },
      "residues": {"3": r3, "5": r5, "9": r9, "11": r11, "13": r13, "17": r17},
      "symmetry_used": "I|M|D|V|MD|VM|...",
      "receipt": {
        "type": "phase_change|governed_exception|entropy|braid_penalty@m|subadditivity_violation",
        "details": {"...": "..."}
      },
      "manifest": "sha256:..."
    }
  ]
}

B. Test battery (n=1â†’4 slice)

T0â€”Codec: encode/decode reversibility on Î£.

T1â€”Pair guards: parity/monotone acceptance census.

T2â€”Triad entropy: selection reproducibility under fixed seeds.

T3â€”Projector canonicality: same input â†’ same 
ğ‘Ÿ
â‹†
r
â‹†
, symmetry tie-breakers stable.

T4â€”Phase receipts: only emitted when 
âˆ£
Î”
ğ»
8
âˆ£
>
0
âˆ£Î”H8âˆ£>0, magnitudes minimal.

T5â€”Subadditivity: witnesses for triples and quads.

T6â€”CRT merges: residues consistent, minimal additional phase spends.

T7â€”Braid certification: helicity constant, strand coherence across moduli.

T8â€”Governance: Î» nonincreasing except with governed receipts; budgets enforced.

C. Design heuristics

Prefer free work first (symmetries), then shortest paid fixes (Lee), then phase preservation, then entropy control.

Make everything a check. Procedures are predicates with witnesses; failures are receipts, not mysteries.

Local first, global last. n=1â†’3 build cheap, local certainty; n=4 locks it in. (From here, n=5â€“8 aggregate capsules, batches, and global geometry, but n=4 is the only truly indispensable hinge.)

D. How n=4 launches the upper levels (teaser)

n=5â€“6 (local capsules/ILPs): subadditivity proves efficient bundling; CRT grows to join multi-stream capsules.

n=7 (batching): budgets and parity-octad families stabilize across many quads; boundary receipts are amortized.

n=8 (global geometry/Eâ‚ˆ): nearest-point snaps, root-path bridges, and large-scale braid structure â€” your â€œdual-helix everywhereâ€ claim shows up as certified two-strand bonds with coherent helicity at every modulation checkpoint.

What to remember

1 (Primitives): make anything look like Î£, log paid atomics, keep free symmetries free.

2 (Mapping): from two primitives + mirror/parity you can map a whole connection and extend edges; CRT residues make local coordinates.

3 (Triads): almost all real choices happen here; budget entropy; either land a shortcut or start a braid.

4 (Quads & Projector): the key to everything. Declare the law, compute phase, run the projector, turn actions into checks, merge with CRT, and certify braidsâ€”with receipts.

If you want, I can expand any section into runnable pseudocode or drop these schemas into your existing deck format so they index alongside your current cards and READMEs.