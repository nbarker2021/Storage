Onboarding Map (read this first)

What youâ€™re building/using:
A universal, auditable transform machine that turns any data into base-4 quads, enforces invariants (ALT, W4âˆ¨Q8), manages phase (H8), prefers free symmetries (Mirror/Dual/Inverse), canonicalizes with a projector (CLTMP), reconciles constraints via CRT (coprime moduli), lifts to Eâ‚ˆ for geometric proofing, and logs every paid move as receipts in a ledger. â€œDo Xâ€ is always rewritten as â€œCheck Y holds (else emit a receipt).â€

1) Core mental model (5 bullets)

Alphabet â†’ quads: Everything becomes digits in Î£={1,2,3,4}, chunked to 4-tuples (â€œquadsâ€).

Lawfulness: A quad is valid if ALT (parity alternates) and (W4 or Q8) holds.

Phase: 
ğ»
8
(
ğ‘
)
=
(
ğ‘
âˆ’
ğ‘‘
)
+
2
(
ğ‘
âˆ’
ğ‘
)
Â 
(
â€Š
m
o
d
â€Š
Â 
8
)
H8(q)=(aâˆ’d)+2(bâˆ’c)Â (modÂ 8). You try not to change it; if you must, receipt the delta.

Free first: Try symmetry moves (M/D/V) before any paid work.

Action-as-check: Procedures are predicates; outputs come with witnesses (proof artifacts) and receipts (what it cost).

2) Minimum notation & facts (cheat sheet)

ALT: parities go odd/even/odd/even (or the even/odd complement).

W4: 
(
ğ‘
+
ğ‘
+
ğ‘
+
ğ‘‘
)
â‰¡
2
(
m
o
d
4
)
(a+b+c+d)â‰¡2(mod4).

Q8: 
(
ğ‘
2
+
ğ‘
2
+
ğ‘
2
+
ğ‘‘
2
)
â‰¡
0
(
m
o
d
8
)
(a
2
+b
2
+c
2
+d
2
)â‰¡0(mod8).

LAWFUL(q): ALT âˆ§ (W4 âˆ¨ Q8).

Phase H8: 
(
ğ‘
âˆ’
ğ‘‘
)
+
2
(
ğ‘
âˆ’
ğ‘
)
(
m
o
d
8
)
(aâˆ’d)+2(bâˆ’c)(mod8).

Symmetries:

M: 
(
ğ‘
,
ğ‘
,
ğ‘
,
ğ‘‘
)
â†’
(
ğ‘‘
,
ğ‘
,
ğ‘
,
ğ‘
)
(a,b,c,d)â†’(d,c,b,a)

D: 
(
ğ‘
,
ğ‘
,
ğ‘
,
ğ‘‘
)
â†’
(
ğ‘
,
ğ‘
,
ğ‘‘
,
ğ‘
)
(a,b,c,d)â†’(b,a,d,c)

V: 
(
ğ‘¥
)
â†’
(
5
âˆ’
ğ‘¥
)
(x)â†’(5âˆ’x) elementwise

Lee distance: per-digit wrap distance; sum over digits.

CRT set: pick coprime moduli (e.g., 3,5,9,11,13,17) for residues and merges.

3) The four levels you must internalize (n=1 â†’ n=4)
n=1 â€” Primitives

Encode to Î£. Track paid unit flips 
ğ‘’
ğ‘–
Â±
e
i
Â±
	â€‹

. Record everything in the operator ledger.

Know your encoder(s) and why theyâ€™re reversible.

n=2 â€” Mapping any space (pairs)

Use guards (parity/monotone/type) to map connections with pairs.

Mirrors give reverse edges for free. Start tagging residues mod small primes; these are your local coordinates.

n=3 â€” Triads, entropy & braid start

When multiple paths are near-equal, budget entropy: keep the best or the top-2 as proto-braid strands if per-modulus checks look good.

Log the choice (weights, entropy spent). Triads decide most â€œrealâ€ choices.

n=4 â€” Quads & Projector (the hinge)

Run CLTMP: symmetry-first â†’ nearest LAWFUL rep â†’ minimize 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£ â†’ tie-break by Lee/phase; emit receipt if phase changed.

CRT: merge cross-modulus residues; prefer representatives that donâ€™t force extra phase spend.

Braid certification: if two strands survived, check helicity/residue coherence and certify (or collapse) with receipts.

If you only master n=1â€“4, you can already reproduce the core system end-to-end.

4) Eâ‚ˆ in one page (why it matters)

Treat legalized quads or sequences as points/paths and snap to the nearest point in Eâ‚ˆ.

Use neighbor checks (the 240 roots) and root-path lengths as proofs that your transforms make geometric sense.

Eâ‚ˆ is your â€œsemantic spaceâ€: if the algebra is right, the geometry is tight. Store snap distances and neighbor IDs as witnesses.

(If you also use the 24D governance layer later, greatâ€”but itâ€™s not required to start.)

5) The two algorithms to know cold
CLTMP Projector (conceptual)

Generate symmetry images of your quad.

For each, find the nearest LAWFUL target in Lee distance.

Prefer phase-preserving solutions; if not possible, minimize 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£ and receipt it.

Pick the best image/target pair; write a deterministic receipt (inputs, symmetry, target, Lee cost, Î”H8, hashes).

CRT Merge (conceptual)

Compute per-modulus residues for a quad/segment.

Solve the congruences to get a class modulo 
ğ‘€
M.

Choose a representative thatâ€™s closest (Lee) to your local lawful anchors and minimizes new phase spend.

Record any per-modulus penalties as receipts.

6) What artifacts to expect (and how to read them)

Cards: short, structured entries describing a dataset, algorithm, runbook, or theorem; each with provenance paths.

Receipts: JSON lines with level, op name, input/output, symmetry used, cost, Î”H8, residue vectors, manifest hash.

Manifests: content-addressed hashes (e.g., SHA-256) for every artifact.

Ledgers: append-only logs that sum costs and cross-link manifests.

Reports: human-readable summaries; the ledger is the source of truth.

A good first habit: open a card â†’ jump to its source README â†’ run the smallest test it references â†’ inspect the receipts.

7) Budgets & dials (safety rails)

Atomic flips (edit cost cap)

Phase spend 
âˆ£
Î”
ğ»
8
âˆ£
âˆ£Î”H8âˆ£ (cap per op / per batch)

Entropy (how often you keep top-2 at n=3)

CRT penalties (per-modulus, per batch)

Î»-energy gate (accept if Î”Î» â‰¤ 0, else log a governed exception)

Keep these visible; most â€œmysteriesâ€ are over-tight or under-tight dials.

8) First-day run plan (90 minutes)

Hello, Î£: encode a tiny payload into digits; record any unit flips.

Pairsâ†’Triples: run pair guards; pick one triad with an entropy receipt.

Project 3â€“5 quads: run CLTMP; confirm LAWFUL; inspect Î”H8 receipts.

Mini-CRT: compute residues at {3,5,11}; merge; check if a phase spend is forced.

Proto-braid: keep two paths for a short segment; try the modulus check (3,5); either certify or collapse.

Eâ‚ˆ snap: snap 5â€“10 legalized quads; record neighbor IDs and distances.

Read a report: open the manifest; verify hashes match the ledger.

You should end with at least one projector receipt, one CRT receipt, one (proto) braid result, and an Eâ‚ˆ snap witness.

9) Common pitfalls (and the fix)

Skipping free symmetries: If costs look high, you probably didnâ€™t try M/D/V first.

Treating W4 and Q8 as interchangeable: LAWFUL is ALT âˆ§ (W4 or Q8); donâ€™t over-constrain.

Letting phase drift silently: Every non-zero Î”H8 must have a receipt; otherwise debugging is pain.

Forcing CRT at high primes early: Decide with small primes (3,5) first; add larger moduli later, priced.

Overusing entropy: Top-2 at n=3 is powerful; budget it, or youâ€™ll drown in branches.

No manifest discipline: Always hash outputs; receipts without hashes arenâ€™t reproducible.

10) Questions to answer before you start

Which encoder(s) map your domain to Î£ and why are they reversible?

Which pair/triad guards are relevant (parity, monotone, type)?

What moduli set do you adopt for CRT and in what order (lowest first)?

What are your budget caps (atomic flips, Î”H8, entropy, CRT penalties)?

What is your acceptance policy (Î» gate, governed exceptions)?

What is the reporting surface (receipts youâ€™ll expose, manifests to publish)?

Write these into your run config so future receipts make sense.

11) A tiny worked micro-example (paper-napkin)

Start with digits: 
[
2
,
4
,
1
,
3
]
[2,4,1,3].

Try symmetries: 
ğ·
D gives 
[
4
,
2
,
3
,
1
]
[4,2,3,1].

Nearest LAWFUL (Lee=1) is 
[
4
,
2
,
2
,
4
]
[4,2,2,4] with 
âˆ£
Î”
ğ»
8
âˆ£
=
0
âˆ£Î”H8âˆ£=0 â†’ projector receipt (cost 1, no phase spend).

Residues (mod 3,5,11) computed; CRT picks a class; representative chosen with no extra Î”H8 â†’ CRT receipt.

Two adjacent quads form two paths; residues and phase slopes align â†’ certify braid or collapse if not.

Thatâ€™s the whole loop in miniature.

12) Reading order (cards/READMEs)

Work-Ordering Guide (n=1â†’4) â€” the spine.

Projector (CLTMP) card/README â€” inputs/outputs, tie-breaks, receipts.

CRT & Reconstruction â€” residue functions, merge policy, penalty receipts.

Universal Order Algebra / Phase â€” why actionâ†’check, H8, invariants.

Braid predicates â€” what counts as a passing two-strand.

Eâ‚ˆ lift â€” how snap/neighbor/root-path are recorded.

Skim those; run the tiny plan above; then go deeper (tests, case studies).

13) Quick glossary

Quad: 4-tuple over Î£.

ALT / W4 / Q8: the law family (alternation; sum mod-4; quadratic sum mod-8).

H8: phase of a quad.

Lee distance: wrap-around digit distance.

CLTMP: the canonical projector (symmetry-first, phase-aware).

Receipt: a priced, structured record of non-free work (or accepted exceptions).

CRT: Chinese Remainder Theorem merge of residues.

Braid: two interleaved lawful strands with coherent helicity.

Eâ‚ˆ snap: nearest-point map into Eâ‚ˆ for geometric witnesses.

Î» gate: accept if energy doesnâ€™t rise (or attach governed exception).