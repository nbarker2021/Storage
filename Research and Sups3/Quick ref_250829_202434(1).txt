UVIBS â€” Quick Reference (v1)
What it is
A math-first legality engine for reasoning: small integer moves in D=8k dimensions, only through gates that pass parity/isotropy. If a strict gate jams, detour via a parametric expansion lane; reconcile at rests; score segments with entropy deltas and Crooks-like suppression.
Objects (memory card)
â€¢ Space: Z^D with D=8k (default 80=E8Ã—10).
â€¢ Gram: G80 = diag(G_E8,â€¦,G_E8). Quadratic form Q(v)=váµ€G80v.
â€¢ Rests (windows): 
â€¢ W4: Î£v â‰¡ 0 (mod 4)
â€¢ W80: Î£v â‰¡ 0 (mod 8) and Q(v) â‰¡ 0 (mod 4)
Modes: global or strict per-block (each 8-slice).
â€¢ Expansion Wexp(p,Î½|8): Q(v) â‰¡ 0 (mod p) & Î£v â‰¡ 0 (mod Î½). 
â€¢ Classic 7/72 mnemonic: p=7, Î½=9 (lcm(8,9)=72).
â€¢ Ï†-lane 11/40: p=11, Î½=10 (lcm(8,10)=40).
Optional bridge: Î£v â‰¡ 0 (mod lcm(8,Î½)).
â€¢ Gates: PAL_b (palindrome), MIRROR(m,b): xâ‰¡rev_b(x) (mod m), Mirror-CRT across several m.
â€¢ Governance (24D): projections Î ; each requires per-block E8 mod-4 + total mod-7; joint legality is intersection ğ’¦.
â€¢ Transforms: fold / split(o) / shear; Monster-aware = base op + AMP repair into ğ’¦.
â€¢ Weights: shell gauge (triad/pentad/octad) Ã— Alena 24-slot cosine.
â€¢ Capacity/Entropy: Î¼_W=Î£ w; S_W=ln Î¼_W; Î”S(Aâ†’B)=S_Bâˆ’S_A; Crooks: P_rev/P_fwd=e^(âˆ’Î”S).
Control flow (4â†’80 or 4â†’expâ†’80)
â€¢ Gate prefilter: require PAL/MIRROR (or both) for the 8-window.
â€¢ Enter rest: fix W4 (Î£vâ‰¡0 mod 4).
â€¢ Governance repair: AMP on a +8 DOF block until all projections pass (ğ’¦).
â€¢ Route choice: 
â€¢ If not strict: try direct 4â†’80 via Monster-aware foldâ†’split.
â€¢ Else (or if jammed): go 4â†’exp(p,Î½)â†’80 (classic 7/9 or Ï† 11/10).
â€¢ Close: at W80; record Î”S, Crooks, repair budget; keep failures with context.
When to use which expansion
â€¢ 7/72 (7,9): clears codec jam when W80 is strict; good default.
â€¢ Ï†-lane (11,10): comparable raw pass; often better re-entry to W80 and lower repair when palindromic structure is strong.
PAL/MIRROR palette
â€¢ For base b: 
â€¢ always include divisors of (bâˆ’1); for even length 8, include divisors of (b+1) too.
â€¢ pair with 8 or 16 to align with codec; add small odd (5 or 7) for CRT flexibility.
Monster-aware transforms
â€¢ fold â‰» split(o=7); avoid shear unless needed.
â€¢ After each base op, run AMP repair on a fixed +8 DOF block; accept only if all projections pass.
Metrics to watch (CSV columns)
â€¢ phase_metrics: S4, S80, Sexp, dS_4_80, dS_80_exp, Crooks*, counts, regime flags.
â€¢ direct_hits: confirmed 4â†’80 geodesics; governance OK; repair steps.
â€¢ relations: pal/mirror flags; residues; small-prime QF; Î”S/jam/re-entry per relation.
Jam proxy: mean(W80)/mean(W4).
Re-entry: P(W80 | Wexp).
Repair budget: mean AMP steps per accepted move.
Common symptoms â†’ fixes
â€¢ Codec jam (strict W80): switch to 4â†’expâ†’80; prefer PALâˆ§MIRROR windows; increase split offset to 7 or 9.
â€¢ Governance clash (overlaps): run AMP with a higher step budget; try foldâ†’split; if still stuck, go via expansion then re-enter.
â€¢ Shear breaks invariants: backtrack; avoid shear unless fold/split fail.
Plugging into an LLM
â€¢ Let the LLM propose 8-windows (pal-biased).
â€¢ Use core gates as referees: reject on PAL/MIRROR fail; otherwise call route_once.
â€¢ Return precise failure reasons (W4_FAIL, GOV_FAIL, EXP_FAIL, REENTRY_FAIL) so the LLM learns to propose legal moves.
â€¢ Rank beams by Î”S gain, jam reduction, and low repair.
Minimal recipes
â€¢ Direct codec (global): PAL/MIRROR â†’ W4 â†’ AMP â†’ foldâ†’split â†’ W80 â†’ log.
â€¢ Strict phase: PALâˆ§MIRROR â†’ W4 â†’ AMP â†’ foldâ†’split â†’ Wexp(7,9) or (11,10) â†’ AMP â†’ W80 â†’ log.
â€¢ Best-of-rest: choose (m,b) with high PALâˆ§MIRROR density + non-negative Î”S_4_80 in your phase; ship as a pack.
Defaults (you can copy these)
â€¢ D=80; projections: mod24, affine 5i+7; control block [40..47]; split offset 7; max AMP steps 100.
â€¢ Base b=10; mirror mods (9,10,8); expansion (7,9) or Ï†-mode (11,10).
Remember: Everything is O(D) checks + tiny +8 DOF repairs. Keep moves small, record every failure, and compare routes with Î”S & Crooksâ€”this is how UVIBS stays fast, legal, and explainable.
Done!
â€¢ I added a runnable wrapper: uvibs_gpt.py â€” it takes a prompt, proposes palindromic 8-windows (or you can plug in your own LLM proposer), lifts them to 80D, and routes them through the UVIBS engine with full logging. Itâ€™s in the canvas.
â€¢ I also added â€œUVIBS Quick Reference v1.mdâ€ â€” a tight, math-first guide for why/how to operate: objects, windows, expansions (7/72 vs Ï†-lane), gates, governance, transforms, routing flow, metrics, and common fixes.
If you want, I can wire the wrapper to your favorite LLM API next (swap out propose_windows()), or add a small demo that reads windows from a CSV and produces a full phase_metrics.csv in one go.